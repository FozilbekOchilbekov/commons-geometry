<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GreatCircles.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Spherical</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.spherical.twod</a> &gt; <span class="el_source">GreatCircles.java</span></div><h1>GreatCircles.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.spherical.twod;

import org.apache.commons.geometry.euclidean.threed.Vector3D;
import org.apache.commons.geometry.spherical.oned.AngularInterval;
import org.apache.commons.geometry.spherical.oned.Point1S;
import org.apache.commons.numbers.core.Precision;

/** Class containing factory methods for constructing {@link GreatCircle} and {@link GreatCircleSubset} instances.
 */
public final class GreatCircles {

    /** Utility class; no instantiation. */
    private GreatCircles() {
    }

    /** Create a great circle instance from its pole vector. An arbitrary u-axis is chosen.
     * @param pole pole vector for the great circle
     * @param precision precision context used to compare floating point values
     * @return a great circle defined by the given pole vector
     */
    public static GreatCircle fromPole(final Vector3D pole, final Precision.DoubleEquivalence precision) {
<span class="fc" id="L38">        final Vector3D.Unit u = pole.orthogonal();</span>
<span class="fc" id="L39">        final Vector3D.Unit v = pole.cross(u).normalize();</span>
<span class="fc" id="L40">        return new GreatCircle(pole.normalize(), u, v, precision);</span>
    }

    /** Create a great circle instance from its pole vector and a vector representing the u-axis
     * in the equator plane. The u-axis vector defines the {@code 0pi} location for the embedded
     * subspace.
     * @param pole pole vector for the great circle
     * @param u u-axis direction for the equator plane
     * @param precision precision context used to compare floating point values
     * @return a great circle defined by the given pole vector and u-axis direction
     */
    public static GreatCircle fromPoleAndU(final Vector3D pole, final Vector3D u,
            final Precision.DoubleEquivalence precision) {

<span class="fc" id="L54">        final Vector3D.Unit unitPole = pole.normalize();</span>
<span class="fc" id="L55">        final Vector3D.Unit unitX = pole.orthogonal(u);</span>
<span class="fc" id="L56">        final Vector3D.Unit unitY = pole.cross(u).normalize();</span>

<span class="fc" id="L58">        return new GreatCircle(unitPole, unitX, unitY, precision);</span>
    }

    /** Create a great circle instance from two points on the circle. The u-axis of the
     * instance points to the location of the first point. The orientation of the circle
     * is along the shortest path between the two points.
     * @param a first point on the great circle
     * @param b second point on the great circle
     * @param precision precision context used to compare floating point values
     * @return great circle instance containing the given points
     * @throws IllegalArgumentException if either of the given points is NaN or infinite, or if the given points are
     *      equal or antipodal as evaluated by the given precision context
     */
    public static GreatCircle fromPoints(final Point2S a, final Point2S b,
            final Precision.DoubleEquivalence precision) {

<span class="fc bfc" id="L74" title="All 4 branches covered.">        if (!a.isFinite() || !b.isFinite()) {</span>
<span class="fc" id="L75">            throw new IllegalArgumentException(&quot;Invalid points for great circle: &quot; + a + &quot;, &quot; + b);</span>
        }

<span class="fc" id="L78">        String err = null;</span>

<span class="fc" id="L80">        final double dist = a.distance(b);</span>
<span class="fc bfc" id="L81" title="All 2 branches covered.">        if (precision.eqZero(dist)) {</span>
<span class="fc" id="L82">            err = &quot;equal&quot;;</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">        } else if (precision.eq(dist, Math.PI)) {</span>
<span class="fc" id="L84">            err = &quot;antipodal&quot;;</span>
        }

<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (err != null) {</span>
<span class="fc" id="L88">            throw new IllegalArgumentException(&quot;Cannot create great circle from points &quot; + a + &quot; and &quot; + b +</span>
                    &quot;: points are &quot; + err);
        }

<span class="fc" id="L92">        final Vector3D.Unit u = a.getVector().normalize();</span>
<span class="fc" id="L93">        final Vector3D.Unit pole = u.cross(b.getVector()).normalize();</span>
<span class="fc" id="L94">        final Vector3D.Unit v = pole.cross(u).normalize();</span>

<span class="fc" id="L96">        return new GreatCircle(pole, u, v, precision);</span>
    }

    /** Construct an arc along the shortest path between the given points. The underlying
     * great circle is oriented in the direction from {@code start} to {@code end}.
     * @param start start point for the interval
     * @param end end point point for the interval
     * @param precision precision context used to compare floating point numbers
     * @return an arc representing the shortest path between the given points
     * @throws IllegalArgumentException if either of the given points is NaN or infinite, or if the given
     *      points are equal or antipodal as evaluated by the given precision context
     * @see GreatCircles#fromPoints(Point2S, Point2S, org.apache.commons.numbers.core.Precision.DoubleEquivalence)
     */
    public static GreatArc arcFromPoints(final Point2S start, final Point2S end,
            final Precision.DoubleEquivalence precision) {
<span class="fc" id="L111">        final GreatCircle circle = GreatCircles.fromPoints(start, end, precision);</span>

<span class="fc" id="L113">        final Point1S subspaceStart = circle.toSubspace(start);</span>
<span class="fc" id="L114">        final Point1S subspaceEnd = circle.toSubspace(end);</span>
<span class="fc" id="L115">        final AngularInterval.Convex interval = AngularInterval.Convex.of(subspaceStart, subspaceEnd, precision);</span>

<span class="fc" id="L117">        return arcFromInterval(circle, interval);</span>
    }

    /** Construct an arc from a great circle and an angular interval.
     * @param circle circle defining the arc
     * @param interval interval representing the portion of the circle contained
     *      in the arc
     * @return an arc created from the given great circle and interval
     */
    public static GreatArc arcFromInterval(final GreatCircle circle, final AngularInterval.Convex interval) {
<span class="fc" id="L127">        return new GreatArc(circle, interval);</span>
    }

    /** Validate that the actual great circle is equivalent to the expected great circle,
     * throwing an exception if not.
     * @param expected the expected great circle
     * @param actual the actual great circle
     * @throws IllegalArgumentException if the actual great circle is not equivalent to the
     *      expected great circle
     */
    static void validateGreatCirclesEquivalent(final GreatCircle expected, final GreatCircle actual) {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (!expected.eq(actual, expected.getPrecision())) {</span>
<span class="fc" id="L139">            throw new IllegalArgumentException(&quot;Arguments do not represent the same great circle. Expected &quot; +</span>
                    expected + &quot; but was &quot; + actual + &quot;.&quot;);
        }
<span class="fc" id="L142">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>