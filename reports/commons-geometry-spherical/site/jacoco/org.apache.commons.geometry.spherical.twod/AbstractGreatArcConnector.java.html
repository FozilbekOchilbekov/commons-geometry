<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractGreatArcConnector.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Spherical</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.spherical.twod</a> &gt; <span class="el_source">AbstractGreatArcConnector.java</span></div><h1>AbstractGreatArcConnector.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.spherical.twod;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import org.apache.commons.geometry.core.internal.GeometryInternalUtils;
import org.apache.commons.geometry.euclidean.internal.AbstractPathConnector;
import org.apache.commons.geometry.euclidean.threed.Vector3D;

/** Abstract class for joining collections of great arcs into connected
 * paths. This class is not thread-safe.
 */
<span class="fc" id="L30">public abstract class AbstractGreatArcConnector</span>
    extends AbstractPathConnector&lt;AbstractGreatArcConnector.ConnectableGreatArc&gt; {
    /** Add an arc to the connector, leaving it unconnected until a later call to
     * to {@link #connect(Iterable)} or {@link #connectAll()}.
     * @param arc arc to add
     * @see #connect(Iterable)
     * @see #connectAll()
     */
    public void add(final GreatArc arc) {
<span class="fc" id="L39">        addPathElement(new ConnectableGreatArc(arc));</span>
<span class="fc" id="L40">    }</span>

    /** Add a collection of arcs to the connector, leaving them unconnected
     * until a later call to {@link #connect(Iterable)} or
     * {@link #connectAll()}.
     * @param arcs arcs to add
     * @see #connect(Iterable)
     * @see #connectAll()
     * @see #add(GreatArc)
     */
    public void add(final Iterable&lt;GreatArc&gt; arcs) {
<span class="fc bfc" id="L51" title="All 2 branches covered.">        for (final GreatArc segment : arcs) {</span>
<span class="fc" id="L52">            add(segment);</span>
<span class="fc" id="L53">        }</span>
<span class="fc" id="L54">    }</span>

    /** Add a collection of arcs to the connector and attempt to connect each new
     * arc with existing ones. Connections made at this time will not be
     * overwritten by subsequent calls to this or other connection methods,
     * (eg, {@link #connectAll()}).
     *
     * &lt;p&gt;The connector is not reset by this call. Additional arc can still be added
     * to the current set of paths.&lt;/p&gt;
     * @param arcs arcs to connect
     * @see #connectAll()
     */
    public void connect(final Iterable&lt;GreatArc&gt; arcs) {
<span class="fc" id="L67">        final List&lt;ConnectableGreatArc&gt; newEntries = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (final GreatArc segment : arcs) {</span>
<span class="fc" id="L70">            newEntries.add(new ConnectableGreatArc(segment));</span>
<span class="fc" id="L71">        }</span>

<span class="fc" id="L73">        connectPathElements(newEntries);</span>
<span class="fc" id="L74">    }</span>

    /** Add the given arcs to this instance and connect all current
     * arc into paths. This call is equivalent to
     * &lt;pre&gt;
     *      connector.add(arcs);
     *      List&amp;lt;GreatArcPath&amp;gt; result = connector.connectAll();
     * &lt;/pre&gt;
     *
     * &lt;p&gt;The connector is reset after this call. Further calls to
     * add or connect arcs will result in new paths being generated.&lt;/p&gt;
     * @param arcs arcs to add
     * @return the connected arc paths
     * @see #add(Iterable)
     * @see #connectAll()
     */
    public List&lt;GreatArcPath&gt; connectAll(final Iterable&lt;GreatArc&gt; arcs) {
<span class="fc" id="L91">        add(arcs);</span>
<span class="fc" id="L92">        return connectAll();</span>
    }

    /** Connect all current arcs into connected paths, returning the result as a
     * list of arc paths.
     *
     * &lt;p&gt;The connector is reset after this call. Further calls to
     * add or connect arcs will result in new paths being generated.&lt;/p&gt;
     * @return the connected line segments paths
     */
    public List&lt;GreatArcPath&gt; connectAll() {
<span class="fc" id="L103">        final List&lt;ConnectableGreatArc&gt; roots = computePathRoots();</span>
<span class="fc" id="L104">        final List&lt;GreatArcPath&gt; paths = new ArrayList&lt;&gt;(roots.size());</span>

<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (final ConnectableGreatArc root : roots) {</span>
<span class="fc" id="L107">            paths.add(toPath(root));</span>
<span class="fc" id="L108">        }</span>

<span class="fc" id="L110">        return paths;</span>
    }

    /** Convert the linked list of path elements starting at the argument
     * into a {@link GreatArcPath}.
     * @param root root of a connected path linked list
     * @return a great arc path representing the linked list path
     */
    private GreatArcPath toPath(final ConnectableGreatArc root) {
<span class="fc" id="L119">        final GreatArcPath.Builder builder = GreatArcPath.builder(null);</span>

<span class="fc" id="L121">        builder.append(root.getArc());</span>

<span class="fc" id="L123">        ConnectableGreatArc current = root.getNext();</span>

<span class="fc bfc" id="L125" title="All 4 branches covered.">        while (current != null &amp;&amp; !GeometryInternalUtils.sameInstance(current, root)) {</span>
<span class="fc" id="L126">            builder.append(current.getArc());</span>
<span class="fc" id="L127">            current = current.getNext();</span>
        }

<span class="fc" id="L130">        return builder.build();</span>
    }

    /** Internal class for connecting {@link GreatArc}s into {@link GreatArcPath}s.
     */
    protected static class ConnectableGreatArc extends AbstractPathConnector.ConnectableElement&lt;ConnectableGreatArc&gt; {
        /** Segment start point. This will be used to connect to other path elements. */
        private final Point2S start;

        /** Great arc for this instance. */
        private final GreatArc arc;

        /** Create a new instance with the given start point. This constructor is
         * intended only for performing searches for other path elements.
         * @param start start point
         */
        public ConnectableGreatArc(final Point2S start) {
<span class="fc" id="L147">            this(start, null);</span>
<span class="fc" id="L148">        }</span>

        /** Create a new instance from the given arc.
         * @param arc arc for the instance
         */
        public ConnectableGreatArc(final GreatArc arc) {
<span class="fc" id="L154">            this(arc.getStartPoint(), arc);</span>
<span class="fc" id="L155">        }</span>

        /** Create a new instance with the given start point and arc.
         * @param start start point
         * @param arc arc for the instance
         */
<span class="fc" id="L161">        private ConnectableGreatArc(final Point2S start, final GreatArc arc) {</span>
<span class="fc" id="L162">            this.start = start;</span>
<span class="fc" id="L163">            this.arc = arc;</span>
<span class="fc" id="L164">        }</span>

        /** Get the arc for the instance.
         * @return the arc for the instance
         */
        public GreatArc getArc() {
<span class="fc" id="L170">            return arc;</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean hasStart() {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">            return start != null;</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean hasEnd() {
<span class="fc bfc" id="L182" title="All 2 branches covered.">            return arc.getEndPoint() != null;</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean endPointsEq(final ConnectableGreatArc other) {
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">            if (hasEnd() &amp;&amp; other.hasEnd()) {</span>
<span class="fc" id="L189">                return arc.getEndPoint()</span>
<span class="fc" id="L190">                        .eq(other.arc.getEndPoint(), arc.getCircle().getPrecision());</span>
            }

<span class="nc" id="L193">            return false;</span>
        }

        /** Return true if this instance has a size equivalent to zero.
         * @return true if this instance has a size equivalent to zero.
         */
        public boolean hasZeroSize() {
<span class="pc bpc" id="L200" title="2 of 4 branches missed.">            return arc != null &amp;&amp; arc.getCircle().getPrecision().eqZero(arc.getSize());</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean canConnectTo(final ConnectableGreatArc next) {
<span class="fc" id="L206">            final Point2S end = arc.getEndPoint();</span>
<span class="fc" id="L207">            final Point2S nextStart = next.start;</span>

<span class="pc bpc" id="L209" title="2 of 4 branches missed.">            return end != null &amp;&amp; nextStart != null &amp;&amp;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                    end.eq(nextStart, arc.getCircle().getPrecision());</span>
        }

        /** {@inheritDoc} */
        @Override
        public double getRelativeAngle(final ConnectableGreatArc other) {
<span class="fc" id="L216">            return arc.getCircle().angle(other.getArc().getCircle());</span>
        }

        /** {@inheritDoc} */
        @Override
        public ConnectableGreatArc getConnectionSearchKey() {
<span class="fc" id="L222">            return new ConnectableGreatArc(arc.getEndPoint());</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean shouldContinueConnectionSearch(final ConnectableGreatArc candidate,
                final boolean ascending) {

<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (candidate.hasStart()) {</span>
<span class="fc" id="L231">                final double candidatePolar = candidate.getArc().getStartPoint().getPolar();</span>
<span class="fc" id="L232">                final double thisPolar = arc.getEndPoint().getPolar();</span>
<span class="fc" id="L233">                final int cmp = arc.getCircle().getPrecision().compare(candidatePolar, thisPolar);</span>

<span class="fc bfc" id="L235" title="All 6 branches covered.">                return ascending ? cmp &lt;= 0 : cmp &gt;= 0;</span>
            }

<span class="nc" id="L238">            return true;</span>
        }

        /** {@inheritDoc} */
        @Override
        public int compareTo(final ConnectableGreatArc other) {
<span class="fc" id="L244">            int cmp = Point2S.POLAR_AZIMUTH_ASCENDING_ORDER.compare(start, other.start);</span>

<span class="fc bfc" id="L246" title="All 2 branches covered.">            if (cmp == 0) {</span>
                // sort entries without arcs before ones with arcs
<span class="fc bfc" id="L248" title="All 2 branches covered.">                final boolean thisHasArc = arc != null;</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">                final boolean otherHasArc = other.arc != null;</span>

<span class="fc" id="L251">                cmp = Boolean.compare(thisHasArc, otherHasArc);</span>

<span class="fc bfc" id="L253" title="All 4 branches covered.">                if (cmp == 0 &amp;&amp; thisHasArc) {</span>
                    // place point-like segments before ones with non-zero length
<span class="fc" id="L255">                    cmp = Boolean.compare(this.hasZeroSize(), other.hasZeroSize());</span>

<span class="pc bpc" id="L257" title="1 of 2 branches missed.">                    if (cmp == 0) {</span>
                        // sort by circle pole
<span class="fc" id="L259">                        cmp = Vector3D.COORDINATE_ASCENDING_ORDER.compare(</span>
<span class="fc" id="L260">                                arc.getCircle().getPole(),</span>
<span class="fc" id="L261">                                other.arc.getCircle().getPole());</span>
                    }
                }
            }

<span class="fc" id="L266">            return cmp;</span>
        }

        /** {@inheritDoc} */
        @Override
        public int hashCode() {
<span class="fc" id="L272">            return Objects.hash(start, arc);</span>
        }

        /** {@inheritDoc} */
        @Override
        public boolean equals(final Object obj) {
<span class="fc bfc" id="L278" title="All 2 branches covered.">            if (this == obj) {</span>
<span class="fc" id="L279">                return true;</span>
            }
<span class="fc bfc" id="L281" title="All 4 branches covered.">            if (obj == null || !this.getClass().equals(obj.getClass())) {</span>
<span class="fc" id="L282">                return false;</span>
            }

<span class="fc" id="L285">            final ConnectableGreatArc other = (ConnectableGreatArc) obj;</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">            return Objects.equals(this.start, other.start) &amp;&amp;</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">                    Objects.equals(this.arc, other.arc);</span>
        }

        /** {@inheritDoc} */
        @Override
        protected ConnectableGreatArc getSelf() {
<span class="fc" id="L293">            return this;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>