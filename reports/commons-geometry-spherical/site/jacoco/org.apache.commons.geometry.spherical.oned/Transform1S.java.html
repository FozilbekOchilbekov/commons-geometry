<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Transform1S.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Spherical</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.spherical.oned</a> &gt; <span class="el_source">Transform1S.java</span></div><h1>Transform1S.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.spherical.oned;

import org.apache.commons.geometry.core.Transform;

/** Implementation of the {@link Transform} interface for spherical 1D points.
 *
 * &lt;p&gt;Similar to the Euclidean 1D
 * {@link org.apache.commons.geometry.euclidean.oned.AffineTransformMatrix1D AffineTransformMatrix1D},
 * this class performs transformations using an internal 1D affine transformation matrix. In the
 * Euclidean case, the matrix contains a scale factor and a translation. Here, the matrix contains
 * a scale/negation factor that takes the values -1 or +1, and a rotation value. This restriction on
 * the allowed values in the matrix is required in order to fulfill the geometric requirements
 * of the {@link Transform} interface. For example, if arbitrary scaling is allowed, the point {@code 0.5pi}
 * could be scaled by 4 to {@code 2pi}, which is equivalent to {@code 0pi}. However, if the inverse scaling
 * of {@code 1/4} is applied to {@code 0pi}, the result is {@code 0pi} and not {@code 0.5pi}. This breaks
 * the {@link Transform} requirement that transforms be inversible.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Instances of this class are guaranteed to be immutable.&lt;/p&gt;
 */
public final class Transform1S implements Transform&lt;Point1S&gt; {
    /** Static instance representing the identity transform. */
<span class="fc" id="L39">    private static final Transform1S IDENTITY = new Transform1S(1, 0);</span>

    /** Static instance that negates azimuth values. */
<span class="fc" id="L42">    private static final Transform1S NEGATION = new Transform1S(-1, 0);</span>

    /** Value to scale the point azimuth by. This will only be +1/-1. */
    private final double scale;

    /** Value to rotate the point azimuth by. */
    private final double rotate;

    /** Construct a new instance from its transform components.
     * @param scale scale value for the transform; must only be +1 or -1
     * @param rotate rotation value
     */
<span class="fc" id="L54">    private Transform1S(final double scale, final double rotate) {</span>
<span class="fc" id="L55">        this.scale = scale;</span>
<span class="fc" id="L56">        this.rotate = rotate;</span>
<span class="fc" id="L57">    }</span>

    /** Return true if the transform negates the azimuth values of transformed
     * points, regardless of any rotation applied subsequently.
     * @return true if the transform negates the azimuth values of transformed
     *      points
     * @see #preservesOrientation()
     */
    public boolean isNegation() {
<span class="fc bfc" id="L66" title="All 2 branches covered.">        return scale &lt;= 0;</span>
    }

    /** Get the rotation value applied by this instance, in radians.
     * @return the rotation value applied by this instance, in radians.
     */
    public double getRotation() {
<span class="fc" id="L73">        return rotate;</span>
    }

    /** {@inheritDoc} */
    @Override
    public Point1S apply(final Point1S pt) {
<span class="fc" id="L79">        final double az = pt.getAzimuth();</span>
<span class="fc" id="L80">        final double resultAz = (az * scale) + rotate;</span>

<span class="fc" id="L82">        return Point1S.of(resultAz);</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean preservesOrientation() {
<span class="fc bfc" id="L88" title="All 2 branches covered.">        return !isNegation();</span>
    }

    /** Return a new transform created by pre-multiplying this instance by a transform
     * producing a rotation with the given angle.
     * @param angle angle to rotate, in radians
     * @return a new transform created by pre-multiplying this instance by a transform
     *      producing a rotation with the given angle
     * @see #createRotation(double)
     */
    public Transform1S rotate(final double angle) {
<span class="fc" id="L99">        return premultiply(createRotation(angle));</span>
    }

    /** Return a new transform created by pre-multiplying this instance by a transform
     * that negates azimuth values.
     * @return a new transform created by pre-multiplying this instance by a transform
     *      that negates azimuth values
     */
    public Transform1S negate() {
<span class="fc" id="L108">        return premultiply(createNegation());</span>
    }

    /** Multiply the underlying matrix of this instance by that of the argument, eg,
     * {@code other * this}. The returned transform performs the equivalent of
     * {@code other} followed by {@code this}.
     * @param other transform to multiply with
     * @return a new transform computed by multiplying the matrix of this
     *      instance by that of the argument
     */
    public Transform1S multiply(final Transform1S other) {
<span class="fc" id="L119">        return multiply(this, other);</span>
    }

    /** Multiply the underlying matrix of the argument by that of this instance, eg,
     * {@code this * other}. The returned transform performs the equivalent of {@code this}
     * followed by {@code other}.
     * @param other transform to multiply with
     * @return a new transform computed by multiplying the matrix of the
     *      argument by that of this instance
     */
    public Transform1S premultiply(final Transform1S other) {
<span class="fc" id="L130">        return multiply(other, this);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Transform1S inverse() {
<span class="fc" id="L136">        final double invScale = 1.0 / scale;</span>

<span class="fc" id="L138">        final double resultRotate = -(rotate * invScale);</span>

<span class="fc" id="L140">        return new Transform1S(invScale, resultRotate);</span>
    }

    /** {@inheritDoc} */
    @Override
    public int hashCode() {
<span class="fc" id="L146">        final int prime = 31;</span>
<span class="fc" id="L147">        int result = 1;</span>

<span class="fc" id="L149">        result = (result * prime) + Double.hashCode(scale);</span>
<span class="fc" id="L150">        result = (result * prime) + Double.hashCode(rotate);</span>

<span class="fc" id="L152">        return result;</span>
    }

    /**
     * Return true if the given object is an instance of {@link Transform1S}
     * and all transform element values are exactly equal.
     * @param obj object to test for equality with the current instance
     * @return true if all transform elements are exactly equal; otherwise false
     */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L163" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L164">            return true;</span>
        }
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (!(obj instanceof Transform1S)) {</span>
<span class="fc" id="L167">            return false;</span>
        }
<span class="fc" id="L169">        final Transform1S other = (Transform1S) obj;</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">        return Double.compare(scale, other.scale) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L172" title="All 2 branches covered.">                Double.compare(rotate, other.rotate) == 0;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {
<span class="fc" id="L178">        final StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L180">        sb.append(this.getClass().getSimpleName())</span>
<span class="fc" id="L181">            .append(&quot;[negate= &quot;)</span>
<span class="fc" id="L182">            .append(isNegation())</span>
<span class="fc" id="L183">            .append(&quot;, rotate= &quot;)</span>
<span class="fc" id="L184">            .append(getRotation())</span>
<span class="fc" id="L185">            .append(']');</span>

<span class="fc" id="L187">        return sb.toString();</span>
    }

    /** Return a transform instance representing the identity transform.
     * @return a transform instance representing the identity transform
     */
    public static Transform1S identity() {
<span class="fc" id="L194">        return IDENTITY;</span>
    }

    /** Return a transform instance that negates azimuth values.
     * @return a transform instance that negates azimuth values.
     */
    public static Transform1S createNegation() {
<span class="fc" id="L201">        return NEGATION;</span>
    }

    /** Return a transform instance that performs a rotation with the given
     * angle.
     * @param angle angle of the rotation, in radians
     * @return a transform instance that performs a rotation with the given
     *      angle
     */
    public static Transform1S createRotation(final double angle) {
<span class="fc" id="L211">        return new Transform1S(1, angle);</span>
    }

    /** Multiply two transforms together as matrices.
     * @param a first transform
     * @param b second transform
     * @return the transform computed as {@code a x b}
     */
    private static Transform1S multiply(final Transform1S a, final Transform1S b) {

        // calculate the matrix elements
<span class="fc" id="L222">        final double resultScale = a.scale * b.scale;</span>
<span class="fc" id="L223">        final double resultRotate = (a.scale * b.rotate) + a.rotate;</span>

<span class="fc" id="L225">        return new Transform1S(resultScale, resultRotate);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>