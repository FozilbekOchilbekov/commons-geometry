<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Bounds3D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.threed</a> &gt; <span class="el_source">Bounds3D.java</span></div><h1>Bounds3D.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.threed;

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;

import org.apache.commons.geometry.core.RegionLocation;
import org.apache.commons.geometry.euclidean.AbstractBounds;
import org.apache.commons.geometry.euclidean.threed.line.Line3D;
import org.apache.commons.geometry.euclidean.threed.line.LineConvexSubset3D;
import org.apache.commons.geometry.euclidean.threed.line.LinecastPoint3D;
import org.apache.commons.geometry.euclidean.threed.line.Linecastable3D;
import org.apache.commons.geometry.euclidean.threed.line.Segment3D;
import org.apache.commons.geometry.euclidean.threed.shape.Parallelepiped;
import org.apache.commons.numbers.core.Precision;

/** Class containing minimum and maximum points defining a 3D axis-aligned bounding box. Unless otherwise
 * noted, floating point comparisons used in this class are strict, meaning that values are considered equal
 * if and only if they match exactly.
 *
 * &lt;p&gt;Instances of this class are guaranteed to be immutable.&lt;/p&gt;
 */
public final class Bounds3D extends AbstractBounds&lt;Vector3D, Bounds3D&gt;
    implements Linecastable3D {

    /** Simple constructor. Callers are responsible for ensuring the min is not greater than max.
     * @param min minimum point
     * @param max maximum point
     */
    private Bounds3D(final Vector3D min, final Vector3D max) {
<span class="fc" id="L48">        super(min, max);</span>
<span class="fc" id="L49">    }</span>

    /** {@inheritDoc} */
    @Override
    public boolean hasSize(final Precision.DoubleEquivalence precision) {
<span class="fc" id="L54">        final Vector3D diag = getDiagonal();</span>

<span class="fc bfc" id="L56" title="All 2 branches covered.">        return !precision.eqZero(diag.getX()) &amp;&amp;</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">                !precision.eqZero(diag.getY()) &amp;&amp;</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">                !precision.eqZero(diag.getZ());</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean contains(final Vector3D pt) {
<span class="fc" id="L64">        final double x = pt.getX();</span>
<span class="fc" id="L65">        final double y = pt.getY();</span>
<span class="fc" id="L66">        final double z = pt.getZ();</span>

<span class="fc" id="L68">        final Vector3D min = getMin();</span>
<span class="fc" id="L69">        final Vector3D max = getMax();</span>

<span class="fc bfc" id="L71" title="All 4 branches covered.">        return x &gt;= min.getX() &amp;&amp; x &lt;= max.getX() &amp;&amp;</span>
<span class="fc bfc" id="L72" title="All 4 branches covered.">                y &gt;= min.getY() &amp;&amp; y &lt;= max.getY() &amp;&amp;</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">                z &gt;= min.getZ() &amp;&amp; z &lt;= max.getZ();</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean contains(final Vector3D pt, final Precision.DoubleEquivalence precision) {
<span class="fc" id="L79">        final double x = pt.getX();</span>
<span class="fc" id="L80">        final double y = pt.getY();</span>
<span class="fc" id="L81">        final double z = pt.getZ();</span>

<span class="fc" id="L83">        final Vector3D min = getMin();</span>
<span class="fc" id="L84">        final Vector3D max = getMax();</span>

<span class="fc bfc" id="L86" title="All 4 branches covered.">        return precision.gte(x, min.getX()) &amp;&amp; precision.lte(x, max.getX()) &amp;&amp;</span>
<span class="fc bfc" id="L87" title="All 4 branches covered.">                precision.gte(y, min.getY()) &amp;&amp; precision.lte(y, max.getY()) &amp;&amp;</span>
<span class="fc bfc" id="L88" title="All 4 branches covered.">                precision.gte(z, min.getZ()) &amp;&amp; precision.lte(z, max.getZ());</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean intersects(final Bounds3D other) {
<span class="fc" id="L94">        final Vector3D aMin = getMin();</span>
<span class="fc" id="L95">        final Vector3D aMax = getMax();</span>

<span class="fc" id="L97">        final Vector3D bMin = other.getMin();</span>
<span class="fc" id="L98">        final Vector3D bMax = other.getMax();</span>

<span class="fc bfc" id="L100" title="All 4 branches covered.">        return aMin.getX() &lt;= bMax.getX() &amp;&amp; aMax.getX() &gt;= bMin.getX() &amp;&amp;</span>
<span class="fc bfc" id="L101" title="All 4 branches covered.">                aMin.getY() &lt;= bMax.getY() &amp;&amp; aMax.getY() &gt;= bMin.getY() &amp;&amp;</span>
<span class="fc bfc" id="L102" title="All 4 branches covered.">                aMin.getZ() &lt;= bMax.getZ() &amp;&amp; aMax.getZ() &gt;= bMin.getZ();</span>
    }

    /** {@inheritDoc} */
    @Override
    public Bounds3D intersection(final Bounds3D other) {
<span class="fc bfc" id="L108" title="All 2 branches covered.">        if (intersects(other)) {</span>
<span class="fc" id="L109">            final Vector3D aMin = getMin();</span>
<span class="fc" id="L110">            final Vector3D aMax = getMax();</span>

<span class="fc" id="L112">            final Vector3D bMin = other.getMin();</span>
<span class="fc" id="L113">            final Vector3D bMax = other.getMax();</span>

            // get the max of the mins and the mins of the maxes
<span class="fc" id="L116">            final double minX = Math.max(aMin.getX(), bMin.getX());</span>
<span class="fc" id="L117">            final double minY = Math.max(aMin.getY(), bMin.getY());</span>
<span class="fc" id="L118">            final double minZ = Math.max(aMin.getZ(), bMin.getZ());</span>

<span class="fc" id="L120">            final double maxX = Math.min(aMax.getX(), bMax.getX());</span>
<span class="fc" id="L121">            final double maxY = Math.min(aMax.getY(), bMax.getY());</span>
<span class="fc" id="L122">            final double maxZ = Math.min(aMax.getZ(), bMax.getZ());</span>

<span class="fc" id="L124">            return new Bounds3D(</span>
<span class="fc" id="L125">                    Vector3D.of(minX, minY, minZ),</span>
<span class="fc" id="L126">                    Vector3D.of(maxX, maxY, maxZ));</span>
        }

<span class="fc" id="L129">        return null; // no intersection</span>
    }

    /** Return {@code true} if the region represented by this instance shares any points with
     * the given line. Floating point comparisons are made using the
     * {@link Line3D#getPrecision() precision} of the line.
     * @param line line to determine intersection with
     * @return {@code true} if the region represented by this instance intersects
     *      the given line
     */
    public boolean intersects(final Line3D line) {
<span class="fc" id="L140">        return intersects(line.span());</span>
    }

    /** Return {@code true} if the region represented by this instance shares any points with
     * the given line convex subset. Floating point comparisons are made using the
     * {@link Line3D#getPrecision() precision} of the subset's line.
     * @param subset line convex subset to determine intersection with
     * @return {@code true} if the region represented by this instance intersects
     *      the given line convex subset
     */
    public boolean intersects(final LineConvexSubset3D subset) {
<span class="fc" id="L151">        return new BoundsLinecaster3D(subset).intersectsRegion();</span>
    }

    /** Return a {@link Segment3D} representing the intersection of the region
     * represented by this instance with the given line or {@code null} if no such
     * intersection exists. Floating point comparisons are made using the
     * {@link Line3D#getPrecision() precision} of the line.
     * @param line line to intersect with
     * @return {@link Segment3D} representing the intersection of the region
     *      represented by this instance with the given line or {@code null}
     *      if no such intersection exists
     */
    public Segment3D intersection(final Line3D line) {
<span class="fc" id="L164">        return intersection(line.span());</span>
    }

    /** Return a {@link Segment3D} representing the intersection of the region
     * represented by this instance with the given line convex subset or {@code null}
     * if no such intersection exists. Floating point comparisons are made using the
     * {@link Line3D#getPrecision() precision} of the subset's line.
     * @param subset line convex subset to intersect with
     * @return {@link Segment3D} representing the intersection of the region
     *      represented by this instance with the given line convex subset or {@code null}
     *      if no such intersection exists
     */
    public Segment3D intersection(final LineConvexSubset3D subset) {
<span class="fc" id="L177">        return new BoundsLinecaster3D(subset).getRegionIntersection();</span>
    }

    /** {@inheritDoc} */
    @Override
    public List&lt;LinecastPoint3D&gt; linecast(final LineConvexSubset3D subset) {
<span class="fc" id="L183">        return new BoundsLinecaster3D(subset).getBoundaryIntersections();</span>
    }

    /** {@inheritDoc} */
    @Override
    public LinecastPoint3D linecastFirst(final LineConvexSubset3D subset) {
<span class="fc" id="L189">        return new BoundsLinecaster3D(subset).getFirstBoundaryIntersection();</span>
    }

    /** {@inheritDoc}
     *
     * @throws IllegalArgumentException if any dimension of the bounding box is zero
     *      as evaluated by the given precision context
     */
    @Override
    public Parallelepiped toRegion(final Precision.DoubleEquivalence precision) {
<span class="fc" id="L199">        return Parallelepiped.axisAligned(getMin(), getMax(), precision);</span>
    }

    /** {@inheritDoc} */
    @Override
    public int hashCode() {
<span class="fc" id="L205">        return Objects.hash(getMin(), getMax());</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L211" title="All 2 branches covered.">        if (obj == this) {</span>
<span class="fc" id="L212">            return true;</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">        } else if (!(obj instanceof Bounds3D)) {</span>
<span class="fc" id="L214">            return false;</span>
        }

<span class="fc" id="L217">        final Bounds3D other = (Bounds3D) obj;</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">        return getMin().equals(other.getMin()) &amp;&amp;</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">                getMax().equals(other.getMax());</span>
    }

    /** Construct a new instance from the given points.
     * @param first first point
     * @param more additional points
     * @return a new instance containing the min and max coordinates values from the input points
     */
    public static Bounds3D from(final Vector3D first, final Vector3D... more) {
<span class="fc" id="L229">        final Builder builder = builder();</span>

<span class="fc" id="L231">        builder.add(first);</span>
<span class="fc" id="L232">        builder.addAll(Arrays.asList(more));</span>

<span class="fc" id="L234">        return builder.build();</span>
    }

    /** Construct a new instance from the given points.
     * @param points input points
     * @return a new instance containing the min and max coordinates values from the input points
     */
    public static Bounds3D from(final Iterable&lt;Vector3D&gt; points) {
<span class="fc" id="L242">        final Builder builder = builder();</span>

<span class="fc" id="L244">        builder.addAll(points);</span>

<span class="fc" id="L246">        return builder.build();</span>
    }

    /** Construct a new {@link Builder} instance for creating bounds.
     * @return a new builder instance for creating bounds
     */
    public static Builder builder() {
<span class="fc" id="L253">        return new Builder();</span>
    }

    /** Class used to construct {@link Bounds3D} instances.
     */
    public static final class Builder {

        /** Minimum x coordinate. */
<span class="fc" id="L261">        private double minX = Double.POSITIVE_INFINITY;</span>

        /** Minimum y coordinate. */
<span class="fc" id="L264">        private double minY = Double.POSITIVE_INFINITY;</span>

        /** Minimum z coordinate. */
<span class="fc" id="L267">        private double minZ = Double.POSITIVE_INFINITY;</span>

        /** Maximum x coordinate. */
<span class="fc" id="L270">        private double maxX = Double.NEGATIVE_INFINITY;</span>

        /** Maximum y coordinate. */
<span class="fc" id="L273">        private double maxY = Double.NEGATIVE_INFINITY;</span>

        /** Maximum z coordinate. */
<span class="fc" id="L276">        private double maxZ = Double.NEGATIVE_INFINITY;</span>

        /** Private constructor; instantiate through factory method. */
<span class="fc" id="L279">        private Builder() { }</span>

        /** Add a point to this instance.
         * @param pt point to add
         * @return this instance
         */
        public Builder add(final Vector3D pt) {
<span class="fc" id="L286">            final double x = pt.getX();</span>
<span class="fc" id="L287">            final double y = pt.getY();</span>
<span class="fc" id="L288">            final double z = pt.getZ();</span>

<span class="fc" id="L290">            minX = Math.min(x, minX);</span>
<span class="fc" id="L291">            minY = Math.min(y, minY);</span>
<span class="fc" id="L292">            minZ = Math.min(z, minZ);</span>

<span class="fc" id="L294">            maxX = Math.max(x, maxX);</span>
<span class="fc" id="L295">            maxY = Math.max(y, maxY);</span>
<span class="fc" id="L296">            maxZ = Math.max(z, maxZ);</span>

<span class="fc" id="L298">            return this;</span>
        }

        /** Add a collection of points to this instance.
         * @param pts points to add
         * @return this instance
         */
        public Builder addAll(final Iterable&lt;? extends Vector3D&gt; pts) {
<span class="fc bfc" id="L306" title="All 2 branches covered.">            for (final Vector3D pt : pts) {</span>
<span class="fc" id="L307">                add(pt);</span>
<span class="fc" id="L308">            }</span>

<span class="fc" id="L310">            return this;</span>
        }

        /** Add the min and max points from the given bounds to this instance.
         * @param bounds bounds containing the min and max points to add
         * @return this instance
         */
        public Builder add(final Bounds3D bounds) {
<span class="fc" id="L318">            add(bounds.getMin());</span>
<span class="fc" id="L319">            add(bounds.getMax());</span>

<span class="fc" id="L321">            return this;</span>
        }

        /** Return true if this builder contains valid min and max coordinate values.
         * @return true if this builder contains valid min and max coordinate values
         */
        public boolean hasBounds() {
<span class="fc bfc" id="L328" title="All 2 branches covered.">            return Double.isFinite(minX) &amp;&amp;</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                    Double.isFinite(minY) &amp;&amp;</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                    Double.isFinite(minZ) &amp;&amp;</span>
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">                    Double.isFinite(maxX) &amp;&amp;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                    Double.isFinite(maxY) &amp;&amp;</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                    Double.isFinite(maxZ);</span>
        }

        /** Create a new {@link Bounds3D} instance from the values in this builder.
         * The builder can continue to be used to create other instances.
         * @return a new bounds instance
         * @throws IllegalStateException if no points were given to the builder or any of the computed
         *      min and max coordinate values are NaN or infinite
         * @see #hasBounds()
         */
        public Bounds3D build() {
<span class="fc" id="L344">            final Vector3D min = Vector3D.of(minX, minY, minZ);</span>
<span class="fc" id="L345">            final Vector3D max = Vector3D.of(maxX, maxY, maxZ);</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">            if (!hasBounds()) {</span>
<span class="fc bfc" id="L348" title="All 4 branches covered.">                if (Double.isInfinite(minX) &amp;&amp; minX &gt; 0 &amp;&amp;</span>
<span class="pc bpc" id="L349" title="1 of 4 branches missed.">                        Double.isInfinite(maxX) &amp;&amp; maxX &lt; 0) {</span>
<span class="fc" id="L350">                    throw new IllegalStateException(&quot;Cannot construct bounds: no points given&quot;);</span>
                }

<span class="fc" id="L353">                throw new IllegalStateException(&quot;Invalid bounds: min= &quot; + min + &quot;, max= &quot; + max);</span>
            }

<span class="fc" id="L356">            return new Bounds3D(min, max);</span>
        }
    }

    /** Subclass of {@link BoundsLinecaster} for 3D space.
     */
    private final class BoundsLinecaster3D extends BoundsLinecaster&lt;Segment3D, LinecastPoint3D&gt; {

        /** Line convex subset to be tested against the bounds. */
        private final LineConvexSubset3D subset;

        /** Line instance for the subset being tested. */
        private final Line3D line;

         /** Construct a new instance for computing bounds intersection information with
          * the given line convex subset.
          * @param subset line convex subset to compute intersection information for
          */
<span class="fc" id="L374">        BoundsLinecaster3D(final LineConvexSubset3D subset) {</span>
<span class="fc" id="L375">            super(subset.getLine().getPrecision());</span>

<span class="fc" id="L377">            this.subset = subset;</span>
<span class="fc" id="L378">            this.line = subset.getLine();</span>
<span class="fc" id="L379">        }</span>

        /** {@inheritDoc} */
        @Override
        protected Segment3D createSegment(final double startAbscissa, final double endAbscissa) {
<span class="fc" id="L384">            return line.segment(startAbscissa, endAbscissa);</span>
        }

        /** {@inheritDoc} */
        @Override
        protected LinecastPoint3D createBoundaryIntersection(final Vector3D pt, final Vector3D normal) {
<span class="fc" id="L390">            return new LinecastPoint3D(pt, normal, line);</span>
        }

        /** {@inheritDoc} */
        @Override
        protected void addBoundaryIntersections(final double abscissa, final List&lt;LinecastPoint3D&gt; results) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">            if (subset.classifyAbscissa(abscissa) != RegionLocation.OUTSIDE) {</span>
<span class="fc" id="L397">                final Vector3D pt = line.toSpace(abscissa);</span>

<span class="fc" id="L399">                addBoundaryIntersectionIfPresent(</span>
                        pt,
                        Vector3D.Unit.MINUS_X,
                        Vector3D.Unit.PLUS_X,
                        Vector3D::getX,
                        results);

<span class="fc" id="L406">                addBoundaryIntersectionIfPresent(</span>
                        pt,
                        Vector3D.Unit.MINUS_Y,
                        Vector3D.Unit.PLUS_Y,
                        Vector3D::getY,
                        results);

<span class="fc" id="L413">                addBoundaryIntersectionIfPresent(</span>
                        pt,
                        Vector3D.Unit.MINUS_Z,
                        Vector3D.Unit.PLUS_Z,
                        Vector3D::getZ,
                        results);
            }
<span class="fc" id="L420">        }</span>

        /** {@inheritDoc} */
        @Override
        protected boolean computeNearFar() {
<span class="fc bfc" id="L425" title="All 2 branches covered.">            return updateNearFar(Vector3D::getX) &amp;&amp;</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">                    updateNearFar(Vector3D::getY) &amp;&amp;</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">                    updateNearFar(Vector3D::getZ);</span>
        }

        /** {@inheritDoc} */
        @Override
        protected Comparator&lt;LinecastPoint3D&gt; getBoundaryIntersectionComparator() {
<span class="fc" id="L433">            return LinecastPoint3D.ABSCISSA_ORDER;</span>
        }

        /** {@inheritDoc} */
        @Override
        protected Vector3D getLineDir() {
<span class="fc" id="L439">            return line.getDirection();</span>
        }

        /** {@inheritDoc} */
        @Override
        protected Vector3D getLineOrigin() {
<span class="fc" id="L445">            return line.getOrigin();</span>
        }

        /** {@inheritDoc} */
        @Override
        protected double getSubspaceStart() {
<span class="fc" id="L451">            return subset.getSubspaceStart();</span>
        }

        /** {@inheritDoc} */
        @Override
        protected double getSubspaceEnd() {
<span class="fc" id="L457">            return subset.getSubspaceEnd();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>