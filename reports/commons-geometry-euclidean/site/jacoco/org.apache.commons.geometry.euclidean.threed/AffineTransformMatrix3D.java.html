<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AffineTransformMatrix3D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.threed</a> &gt; <span class="el_source">AffineTransformMatrix3D.java</span></div><h1>AffineTransformMatrix3D.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.threed;

import java.util.function.UnaryOperator;

import org.apache.commons.geometry.core.internal.DoubleFunction3N;
import org.apache.commons.geometry.euclidean.AbstractAffineTransformMatrix;
import org.apache.commons.geometry.euclidean.internal.Matrices;
import org.apache.commons.geometry.euclidean.internal.Vectors;
import org.apache.commons.geometry.euclidean.threed.rotation.QuaternionRotation;

/** Class using a matrix to represent affine transformations in 3 dimensional Euclidean space.
 *
 * &lt;p&gt;Instances of this class use a 4x4 matrix for all transform operations.
 * The last row of this matrix is always set to the values &lt;code&gt;[0 0 0 1]&lt;/code&gt; and so
 * is not stored. Hence, the methods in this class that accept or return arrays always
 * use arrays containing 12 elements, instead of 16.
 * &lt;/p&gt;
 */
public final class AffineTransformMatrix3D extends AbstractAffineTransformMatrix&lt;Vector3D, AffineTransformMatrix3D&gt; {
    /** The number of internal matrix elements. */
    private static final int NUM_ELEMENTS = 12;

    /** String used to start the transform matrix string representation. */
    private static final String MATRIX_START = &quot;[ &quot;;

    /** String used to end the transform matrix string representation. */
    private static final String MATRIX_END = &quot; ]&quot;;

    /** String used to separate elements in the matrix string representation. */
    private static final String ELEMENT_SEPARATOR = &quot;, &quot;;

    /** String used to separate rows in the matrix string representation. */
    private static final String ROW_SEPARATOR = &quot;; &quot;;

    /** Shared transform set to the identity matrix. */
<span class="fc" id="L52">    private static final AffineTransformMatrix3D IDENTITY_INSTANCE = new AffineTransformMatrix3D(</span>
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0
            );

    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;0,0&lt;/sub&gt;&lt;/code&gt;. */
    private final double m00;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;0,1&lt;/sub&gt;&lt;/code&gt;. */
    private final double m01;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;0,2&lt;/sub&gt;&lt;/code&gt;. */
    private final double m02;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;0,3&lt;/sub&gt;&lt;/code&gt;. */
    private final double m03;

    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;1,0&lt;/sub&gt;&lt;/code&gt;. */
    private final double m10;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;1,1&lt;/sub&gt;&lt;/code&gt;. */
    private final double m11;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;1,2&lt;/sub&gt;&lt;/code&gt;. */
    private final double m12;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;1,3&lt;/sub&gt;&lt;/code&gt;. */
    private final double m13;

    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;2,0&lt;/sub&gt;&lt;/code&gt;. */
    private final double m20;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;2,1&lt;/sub&gt;&lt;/code&gt;. */
    private final double m21;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;2,2&lt;/sub&gt;&lt;/code&gt;. */
    private final double m22;
    /** Transform matrix entry &lt;code&gt;m&lt;sub&gt;2,3&lt;/sub&gt;&lt;/code&gt;. */
    private final double m23;

    /**
     * Package-private constructor; sets all internal matrix elements.
     * @param m00 matrix entry &lt;code&gt;m&lt;sub&gt;0,0&lt;/sub&gt;&lt;/code&gt;
     * @param m01 matrix entry &lt;code&gt;m&lt;sub&gt;0,1&lt;/sub&gt;&lt;/code&gt;
     * @param m02 matrix entry &lt;code&gt;m&lt;sub&gt;0,2&lt;/sub&gt;&lt;/code&gt;
     * @param m03 matrix entry &lt;code&gt;m&lt;sub&gt;0,3&lt;/sub&gt;&lt;/code&gt;
     * @param m10 matrix entry &lt;code&gt;m&lt;sub&gt;1,0&lt;/sub&gt;&lt;/code&gt;
     * @param m11 matrix entry &lt;code&gt;m&lt;sub&gt;1,1&lt;/sub&gt;&lt;/code&gt;
     * @param m12 matrix entry &lt;code&gt;m&lt;sub&gt;1,2&lt;/sub&gt;&lt;/code&gt;
     * @param m13 matrix entry &lt;code&gt;m&lt;sub&gt;1,3&lt;/sub&gt;&lt;/code&gt;
     * @param m20 matrix entry &lt;code&gt;m&lt;sub&gt;2,0&lt;/sub&gt;&lt;/code&gt;
     * @param m21 matrix entry &lt;code&gt;m&lt;sub&gt;2,1&lt;/sub&gt;&lt;/code&gt;
     * @param m22 matrix entry &lt;code&gt;m&lt;sub&gt;2,2&lt;/sub&gt;&lt;/code&gt;
     * @param m23 matrix entry &lt;code&gt;m&lt;sub&gt;2,3&lt;/sub&gt;&lt;/code&gt;
     */
    private AffineTransformMatrix3D(
            final double m00, final double m01, final double m02, final double m03,
            final double m10, final double m11, final double m12, final double m13,
<span class="fc" id="L103">            final double m20, final double m21, final double m22, final double m23) {</span>

<span class="fc" id="L105">        this.m00 = m00;</span>
<span class="fc" id="L106">        this.m01 = m01;</span>
<span class="fc" id="L107">        this.m02 = m02;</span>
<span class="fc" id="L108">        this.m03 = m03;</span>

<span class="fc" id="L110">        this.m10 = m10;</span>
<span class="fc" id="L111">        this.m11 = m11;</span>
<span class="fc" id="L112">        this.m12 = m12;</span>
<span class="fc" id="L113">        this.m13 = m13;</span>

<span class="fc" id="L115">        this.m20 = m20;</span>
<span class="fc" id="L116">        this.m21 = m21;</span>
<span class="fc" id="L117">        this.m22 = m22;</span>
<span class="fc" id="L118">        this.m23 = m23;</span>
<span class="fc" id="L119">    }</span>

    /** Return a 12 element array containing the variable elements from the
     * internal transformation matrix. The elements are in row-major order.
     * The array indices map to the internal matrix as follows:
     * &lt;pre&gt;
     *      [
     *          arr[0],   arr[1],   arr[2],   arr[3]
     *          arr[4],   arr[5],   arr[6],   arr[7],
     *          arr[8],   arr[9],   arr[10],  arr[11],
     *          0         0         0         1
     *      ]
     * &lt;/pre&gt;
     * @return 12 element array containing the variable elements from the
     *      internal transformation matrix
     */
    public double[] toArray() {
<span class="fc" id="L136">        return new double[] {</span>
            m00, m01, m02, m03,
            m10, m11, m12, m13,
            m20, m21, m22, m23
        };
    }

    /** Apply this transform to the given point, returning the result as a new instance.
     *
     * &lt;p&gt;The transformed point is computed by creating a 4-element column vector from the
     * coordinates in the input and setting the last element to 1. This is then multiplied with the
     * 4x4 transform matrix to produce the transformed point. The {@code 1} in the last position
     * is ignored.
     * &lt;pre&gt;
     *      [ m00  m01  m02  m03 ]     [ x ]     [ x']
     *      [ m10  m11  m12  m13 ]  *  [ y ]  =  [ y']
     *      [ m20  m21  m22  m23 ]     [ z ]     [ z']
     *      [ 0    0    0    1   ]     [ 1 ]     [ 1 ]
     * &lt;/pre&gt;
     */
    @Override
    public Vector3D apply(final Vector3D pt) {
<span class="fc" id="L158">        final double x = pt.getX();</span>
<span class="fc" id="L159">        final double y = pt.getY();</span>
<span class="fc" id="L160">        final double z = pt.getZ();</span>

<span class="fc" id="L162">        return Vector3D.of(</span>
<span class="fc" id="L163">                applyX(x, y, z),</span>
<span class="fc" id="L164">                applyY(x, y, z),</span>
<span class="fc" id="L165">                applyZ(x, y, z));</span>
    }

    /** Apply this transform to the given point coordinates and return the transformed
     * x value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;00&lt;/sub&gt;) + (y * m&lt;sub&gt;01&lt;/sub&gt;) + (z * m&lt;sub&gt;02&lt;/sub&gt;) + m&lt;sub&gt;03&lt;/sub&gt;&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed x coordinate value
     * @see #apply(Vector3D)
     */
    public double applyX(final double x, final double y, final double z) {
<span class="fc" id="L178">        return applyVectorX(x, y, z) + m03;</span>
    }

    /** Apply this transform to the given point coordinates and return the transformed
     * y value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;10&lt;/sub&gt;) + (y * m&lt;sub&gt;11&lt;/sub&gt;) + (z * m&lt;sub&gt;12&lt;/sub&gt;) + m&lt;sub&gt;13&lt;/sub&gt;&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed y coordinate value
     * @see #apply(Vector3D)
     */
    public double applyY(final double x, final double y, final double z) {
<span class="fc" id="L191">        return applyVectorY(x, y, z) + m13;</span>
    }

    /** Apply this transform to the given point coordinates and return the transformed
     * z value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;20&lt;/sub&gt;) + (y * m&lt;sub&gt;21&lt;/sub&gt;) + (z * m&lt;sub&gt;22&lt;/sub&gt;) + m&lt;sub&gt;23&lt;/sub&gt;&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed z coordinate value
     * @see #apply(Vector3D)
     */
    public double applyZ(final double x, final double y, final double z) {
<span class="fc" id="L204">        return applyVectorZ(x, y, z) + m23;</span>
    }

    /** {@inheritDoc}
     *
     *  &lt;p&gt;The transformed vector is computed by creating a 4-element column vector from the
     * coordinates in the input and setting the last element to 0. This is then multiplied with the
     * 4x4 transform matrix to produce the transformed vector. The {@code 0} in the last position
     * is ignored.
     * &lt;pre&gt;
     *      [ m00  m01  m02  m03 ]     [ x ]     [ x']
     *      [ m10  m11  m12  m13 ]  *  [ y ]  =  [ y']
     *      [ m20  m21  m22  m23 ]     [ z ]     [ z']
     *      [ 0    0    0    1   ]     [ 0 ]     [ 0 ]
     * &lt;/pre&gt;
     *
     * @see #applyDirection(Vector3D)
     */
    @Override
    public Vector3D applyVector(final Vector3D vec) {
<span class="fc" id="L224">        return applyVector(vec, Vector3D::of);</span>
    }

    /** Apply this transform to the given vector coordinates, ignoring translations, and
     * return the transformed x value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;00&lt;/sub&gt;) + (y * m&lt;sub&gt;01&lt;/sub&gt;) + (z * m&lt;sub&gt;02&lt;/sub&gt;)&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed x coordinate value
     * @see #applyVector(Vector3D)
     */
    public double applyVectorX(final double x, final double y, final double z) {
<span class="fc" id="L237">        return Vectors.linearCombination(m00, x, m01, y, m02, z);</span>
    }

    /** Apply this transform to the given vector coordinates, ignoring translations, and
     * return the transformed y value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;10&lt;/sub&gt;) + (y * m&lt;sub&gt;11&lt;/sub&gt;) + (z * m&lt;sub&gt;12&lt;/sub&gt;)&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed y coordinate value
     * @see #applyVector(Vector3D)
     */
    public double applyVectorY(final double x, final double y, final double z) {
<span class="fc" id="L250">        return Vectors.linearCombination(m10, x, m11, y, m12, z);</span>
    }

    /** Apply this transform to the given vector coordinates, ignoring translations, and
     * return the transformed z value. The return value is equal to
     * &lt;code&gt;(x * m&lt;sub&gt;20&lt;/sub&gt;) + (y * m&lt;sub&gt;21&lt;/sub&gt;) + (z * m&lt;sub&gt;22&lt;/sub&gt;)&lt;/code&gt;.
     * @param x x coordinate value
     * @param y y coordinate value
     * @param z z coordinate value
     * @return transformed z coordinate value
     * @see #applyVector(Vector3D)
     */
    public double applyVectorZ(final double x, final double y, final double z) {
<span class="fc" id="L263">        return Vectors.linearCombination(m20, x, m21, y, m22, z);</span>
    }

    /** {@inheritDoc}
     * @see #applyVector(Vector3D)
     */
    @Override
    public Vector3D.Unit applyDirection(final Vector3D vec) {
<span class="fc" id="L271">        return applyVector(vec, Vector3D.Unit::from);</span>
    }

    /** {@inheritDoc} */
    @Override
    public double determinant() {
<span class="fc" id="L277">        return Matrices.determinant(</span>
                m00, m01, m02,
                m10, m11, m12,
                m20, m21, m22
            );
    }

    /** {@inheritDoc}
     *
     * &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;
     * &lt;pre&gt;
     *      [ a, b, c, d ]   [ a, b, c, 0 ]
     *      [ e, f, g, h ]   [ e, f, g, 0 ]
     *      [ i, j, k, l ] &amp;rarr; [ i, j, k, 0 ]
     *      [ 0, 0, 0, 1 ]   [ 0, 0, 0, 1 ]
     * &lt;/pre&gt;
     */
    @Override
    public AffineTransformMatrix3D linear() {
<span class="fc" id="L296">        return new AffineTransformMatrix3D(</span>
                m00, m01, m02, 0.0,
                m10, m11, m12, 0.0,
                m20, m21, m22, 0.0);
    }

    /** {@inheritDoc}
     *
     * &lt;p&gt;&lt;strong&gt;Example&lt;/strong&gt;
     * &lt;pre&gt;
     *      [ a, b, c, d ]   [ a, e, i, 0 ]
     *      [ e, f, g, h ]   [ b, f, j, 0 ]
     *      [ i, j, k, l ] &amp;rarr; [ c, g, k, 0 ]
     *      [ 0, 0, 0, 1 ]   [ 0, 0, 0, 1 ]
     * &lt;/pre&gt;
     */
    @Override
    public AffineTransformMatrix3D linearTranspose() {
<span class="fc" id="L314">        return new AffineTransformMatrix3D(</span>
                m00, m10, m20, 0.0,
                m01, m11, m21, 0.0,
                m02, m12, m22, 0.0);
    }

    /** Apply a translation to the current instance, returning the result as a new transform.
     * @param translation vector containing the translation values for each axis
     * @return a new transform containing the result of applying a translation to
     *      the current instance
     */
    public AffineTransformMatrix3D translate(final Vector3D translation) {
<span class="fc" id="L326">        return translate(translation.getX(), translation.getY(), translation.getZ());</span>
    }

    /** Apply a translation to the current instance, returning the result as a new transform.
     * @param x translation in the x direction
     * @param y translation in the y direction
     * @param z translation in the z direction
     * @return a new transform containing the result of applying a translation to
     *      the current instance
     */
    public AffineTransformMatrix3D translate(final double x, final double y, final double z) {
<span class="fc" id="L337">        return new AffineTransformMatrix3D(</span>
                    m00, m01, m02, m03 + x,
                    m10, m11, m12, m13 + y,
                    m20, m21, m22, m23 + z
                );
    }

    /** Apply a scale operation to the current instance, returning the result as a new transform.
     * @param factor the scale factor to apply to all axes
     * @return a new transform containing the result of applying a scale operation to
     *      the current instance
     */
    public AffineTransformMatrix3D scale(final double factor) {
<span class="fc" id="L350">        return scale(factor, factor, factor);</span>
    }

    /** Apply a scale operation to the current instance, returning the result as a new transform.
     * @param scaleFactors vector containing scale factors for each axis
     * @return a new transform containing the result of applying a scale operation to
     *      the current instance
     */
    public AffineTransformMatrix3D scale(final Vector3D scaleFactors) {
<span class="fc" id="L359">        return scale(scaleFactors.getX(), scaleFactors.getY(), scaleFactors.getZ());</span>
    }

    /** Apply a scale operation to the current instance, returning the result as a new transform.
     * @param x scale factor for the x axis
     * @param y scale factor for the y axis
     * @param z scale factor for the z axis
     * @return a new transform containing the result of applying a scale operation to
     *      the current instance
     */
    public AffineTransformMatrix3D scale(final double x, final double y, final double z) {
<span class="fc" id="L370">        return new AffineTransformMatrix3D(</span>
                    m00 * x, m01 * x, m02 * x, m03 * x,
                    m10 * y, m11 * y, m12 * y, m13 * y,
                    m20 * z, m21 * z, m22 * z, m23 * z
                );
    }

    /** Apply a rotation to the current instance, returning the result as a new transform.
     * @param rotation the rotation to apply
     * @return a new transform containing the result of applying a rotation to the
     *      current instance
     * @see QuaternionRotation#toMatrix()
     */
    public AffineTransformMatrix3D rotate(final QuaternionRotation rotation) {
<span class="fc" id="L384">        return multiply(rotation.toMatrix(), this);</span>
    }

    /** Apply a rotation around the given center point to the current instance, returning the result
     * as a new transform. This is achieved by translating the center point to the origin, applying
     * the rotation, and then translating back.
     * @param center the center of rotation
     * @param rotation the rotation to apply
     * @return a new transform containing the result of applying a rotation about the given center
     *      point to the current instance
     * @see QuaternionRotation#toMatrix()
     */
    public AffineTransformMatrix3D rotate(final Vector3D center, final QuaternionRotation rotation) {
<span class="fc" id="L397">        return multiply(createRotation(center, rotation), this);</span>
    }

    /** Get a new transform created by multiplying this instance by the argument.
     * This is equivalent to the expression {@code A * M} where {@code A} is the
     * current transform matrix and {@code M} is the given transform matrix. In
     * terms of transformations, applying the returned matrix is equivalent to
     * applying {@code M} and &lt;em&gt;then&lt;/em&gt; applying {@code A}. In other words,
     * the rightmost transform is applied first.
     *
     * @param m the transform to multiply with
     * @return the result of multiplying the current instance by the given
     *      transform matrix
     */
    public AffineTransformMatrix3D multiply(final AffineTransformMatrix3D m) {
<span class="fc" id="L412">        return multiply(this, m);</span>
    }

    /** Get a new transform created by multiplying the argument by this instance.
     * This is equivalent to the expression {@code M * A} where {@code A} is the
     * current transform matrix and {@code M} is the given transform matrix. In
     * terms of transformations, applying the returned matrix is equivalent to
     * applying {@code A} and &lt;em&gt;then&lt;/em&gt; applying {@code M}. In other words,
     * the rightmost transform is applied first.
     *
     * @param m the transform to multiply with
     * @return the result of multiplying the given transform matrix by the current
     *      instance
     */
    public AffineTransformMatrix3D premultiply(final AffineTransformMatrix3D m) {
<span class="fc" id="L427">        return multiply(m, this);</span>
    }

    /** {@inheritDoc}
    *
    * @throws IllegalStateException if the matrix cannot be inverted
    */
    @Override
    public AffineTransformMatrix3D inverse() {

        // Our full matrix is 4x4 but we can significantly reduce the amount of computations
        // needed here since we know that our last row is [0 0 0 1].

<span class="fc" id="L440">        final double det = Matrices.checkDeterminantForInverse(determinant());</span>

        // validate the remaining matrix elements that were not part of the determinant
<span class="fc" id="L443">        Matrices.checkElementForInverse(m03);</span>
<span class="fc" id="L444">        Matrices.checkElementForInverse(m13);</span>
<span class="fc" id="L445">        Matrices.checkElementForInverse(m23);</span>

        // compute the necessary elements of the cofactor matrix
        // (we need all but the last column)

<span class="fc" id="L450">        final double invDet = 1.0 / det;</span>

<span class="fc" id="L452">        final double c00 = invDet * Matrices.determinant(m11, m12, m21, m22);</span>
<span class="fc" id="L453">        final double c01 = -invDet * Matrices.determinant(m10, m12, m20, m22);</span>
<span class="fc" id="L454">        final double c02 = invDet * Matrices.determinant(m10, m11, m20, m21);</span>

<span class="fc" id="L456">        final double c10 = -invDet * Matrices.determinant(m01, m02, m21, m22);</span>
<span class="fc" id="L457">        final double c11 = invDet * Matrices.determinant(m00, m02, m20, m22);</span>
<span class="fc" id="L458">        final double c12 = -invDet * Matrices.determinant(m00, m01, m20, m21);</span>

<span class="fc" id="L460">        final double c20 = invDet * Matrices.determinant(m01, m02, m11, m12);</span>
<span class="fc" id="L461">        final double c21 = -invDet * Matrices.determinant(m00, m02, m10, m12);</span>
<span class="fc" id="L462">        final double c22 = invDet * Matrices.determinant(m00, m01, m10, m11);</span>

<span class="fc" id="L464">        final double c30 = -invDet * Matrices.determinant(</span>
                    m01, m02, m03,
                    m11, m12, m13,
                    m21, m22, m23
                );
<span class="fc" id="L469">        final double c31 = invDet * Matrices.determinant(</span>
                    m00, m02, m03,
                    m10, m12, m13,
                    m20, m22, m23
                );
<span class="fc" id="L474">        final double c32 = -invDet * Matrices.determinant(</span>
                    m00, m01, m03,
                    m10, m11, m13,
                    m20, m21, m23
                );

<span class="fc" id="L480">        return new AffineTransformMatrix3D(</span>
                    c00, c10, c20, c30,
                    c01, c11, c21, c31,
                    c02, c12, c22, c32
                );
    }

    /** {@inheritDoc} */
    @Override
    public int hashCode() {
<span class="fc" id="L490">        final int prime = 31;</span>
<span class="fc" id="L491">        int result = 1;</span>

<span class="fc" id="L493">        result = (result * prime) + (Double.hashCode(m00) - Double.hashCode(m01) +</span>
<span class="fc" id="L494">                Double.hashCode(m02) - Double.hashCode(m03));</span>
<span class="fc" id="L495">        result = (result * prime) + (Double.hashCode(m10) - Double.hashCode(m11) +</span>
<span class="fc" id="L496">                Double.hashCode(m12) - Double.hashCode(m13));</span>
<span class="fc" id="L497">        result = (result * prime) + (Double.hashCode(m20) - Double.hashCode(m21) +</span>
<span class="fc" id="L498">                Double.hashCode(m22) - Double.hashCode(m23));</span>

<span class="fc" id="L500">        return result;</span>
    }

    /**
     * Return true if the given object is an instance of {@link AffineTransformMatrix3D}
     * and all matrix element values are exactly equal.
     * @param obj object to test for equality with the current instance
     * @return true if all transform matrix elements are exactly equal; otherwise false
     */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L511" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L512">            return true;</span>
        }
<span class="fc bfc" id="L514" title="All 2 branches covered.">        if (!(obj instanceof AffineTransformMatrix3D)) {</span>
<span class="fc" id="L515">            return false;</span>
        }

<span class="fc" id="L518">        final AffineTransformMatrix3D other = (AffineTransformMatrix3D) obj;</span>

<span class="fc bfc" id="L520" title="All 2 branches covered.">        return Double.compare(this.m00, other.m00) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                Double.compare(this.m01, other.m01) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L522" title="All 2 branches covered.">                Double.compare(this.m02, other.m02) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">                Double.compare(this.m03, other.m03) == 0 &amp;&amp;</span>

<span class="fc bfc" id="L525" title="All 2 branches covered.">                Double.compare(this.m10, other.m10) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">                Double.compare(this.m11, other.m11) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L527" title="All 2 branches covered.">                Double.compare(this.m12, other.m12) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">                Double.compare(this.m13, other.m13) == 0 &amp;&amp;</span>

<span class="fc bfc" id="L530" title="All 2 branches covered.">                Double.compare(this.m20, other.m20) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L531" title="All 2 branches covered.">                Double.compare(this.m21, other.m21) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L532" title="All 2 branches covered.">                Double.compare(this.m22, other.m22) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">                Double.compare(this.m23, other.m23) == 0;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {
<span class="fc" id="L539">        final StringBuilder sb = new StringBuilder();</span>

<span class="fc" id="L541">        sb.append(MATRIX_START)</span>

<span class="fc" id="L543">            .append(m00)</span>
<span class="fc" id="L544">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L545">            .append(m01)</span>
<span class="fc" id="L546">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L547">            .append(m02)</span>
<span class="fc" id="L548">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L549">            .append(m03)</span>
<span class="fc" id="L550">            .append(ROW_SEPARATOR)</span>

<span class="fc" id="L552">            .append(m10)</span>
<span class="fc" id="L553">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L554">            .append(m11)</span>
<span class="fc" id="L555">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L556">            .append(m12)</span>
<span class="fc" id="L557">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L558">            .append(m13)</span>
<span class="fc" id="L559">            .append(ROW_SEPARATOR)</span>

<span class="fc" id="L561">            .append(m20)</span>
<span class="fc" id="L562">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L563">            .append(m21)</span>
<span class="fc" id="L564">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L565">            .append(m22)</span>
<span class="fc" id="L566">            .append(ELEMENT_SEPARATOR)</span>
<span class="fc" id="L567">            .append(m23)</span>

<span class="fc" id="L569">            .append(MATRIX_END);</span>

<span class="fc" id="L571">        return sb.toString();</span>
    }

    /** Multiplies the given vector by the 3x3 linear transformation matrix contained in the
     * upper-right corner of the affine transformation matrix. This applies all transformation
     * operations except for translations. The computed coordinates are passed to the given
     * factory function.
     * @param &lt;T&gt; factory output type
     * @param vec the vector to transform
     * @param factory the factory instance that will be passed the transformed coordinates
     * @return the factory return value
     */
    private &lt;T&gt; T applyVector(final Vector3D vec, final DoubleFunction3N&lt;T&gt; factory) {
<span class="fc" id="L584">        final double x = vec.getX();</span>
<span class="fc" id="L585">        final double y = vec.getY();</span>
<span class="fc" id="L586">        final double z = vec.getZ();</span>

<span class="fc" id="L588">        return factory.apply(</span>
<span class="fc" id="L589">                applyVectorX(x, y, z),</span>
<span class="fc" id="L590">                applyVectorY(x, y, z),</span>
<span class="fc" id="L591">                applyVectorZ(x, y, z));</span>
    }

    /** Get a new transform with the given matrix elements. The array must contain 12 elements.
     * @param arr 12-element array containing values for the variable entries in the
     *      transform matrix
     * @return a new transform initialized with the given matrix values
     * @throws IllegalArgumentException if the array does not have 12 elements
     */
    public static AffineTransformMatrix3D of(final double... arr) {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (arr.length != NUM_ELEMENTS) {</span>
<span class="fc" id="L602">            throw new IllegalArgumentException(&quot;Dimension mismatch: &quot; + arr.length + &quot; != &quot; + NUM_ELEMENTS);</span>
        }

<span class="fc" id="L605">        return new AffineTransformMatrix3D(</span>
                    arr[0], arr[1], arr[2], arr[3],
                    arr[4], arr[5], arr[6], arr[7],
                    arr[8], arr[9], arr[10], arr[11]
                );
    }

    /** Construct a new transform representing the given function. The function is sampled at
     * the origin and along each axis and a matrix is created to perform the transformation.
     * @param fn function to create a transform matrix from
     * @return a transform matrix representing the given function
     * @throws IllegalArgumentException if the given function does not represent a valid
     *      affine transform
     */
    public static AffineTransformMatrix3D from(final UnaryOperator&lt;Vector3D&gt; fn) {
<span class="fc" id="L620">        final Vector3D tPlusX = fn.apply(Vector3D.Unit.PLUS_X);</span>
<span class="fc" id="L621">        final Vector3D tPlusY = fn.apply(Vector3D.Unit.PLUS_Y);</span>
<span class="fc" id="L622">        final Vector3D tPlusZ = fn.apply(Vector3D.Unit.PLUS_Z);</span>
<span class="fc" id="L623">        final Vector3D tZero = fn.apply(Vector3D.ZERO);</span>

<span class="fc" id="L625">        final Vector3D u = tPlusX.subtract(tZero);</span>
<span class="fc" id="L626">        final Vector3D v = tPlusY.subtract(tZero);</span>
<span class="fc" id="L627">        final Vector3D w = tPlusZ.subtract(tZero);</span>

<span class="fc" id="L629">        final AffineTransformMatrix3D mat =  AffineTransformMatrix3D.fromColumnVectors(u, v, w, tZero);</span>

<span class="fc" id="L631">        final double det = mat.determinant();</span>
<span class="fc bfc" id="L632" title="All 2 branches covered.">        if (!Vectors.isRealNonZero(det)) {</span>
<span class="fc" id="L633">            throw new IllegalArgumentException(&quot;Transform function is invalid: matrix determinant is &quot; + det);</span>
        }

<span class="fc" id="L636">        return mat;</span>
    }

    /** Get a new transform create from the given column vectors. The returned transform
     * does not include any translation component.
     * @param u first column vector; this corresponds to the first basis vector
     *      in the coordinate frame
     * @param v second column vector; this corresponds to the second basis vector
     *      in the coordinate frame
     * @param w third column vector; this corresponds to the third basis vector
     *      in the coordinate frame
     * @return a new transform with the given column vectors
     */
    public static AffineTransformMatrix3D fromColumnVectors(final Vector3D u, final Vector3D v, final Vector3D w) {
<span class="fc" id="L650">        return fromColumnVectors(u, v, w, Vector3D.ZERO);</span>
    }

    /** Get a new transform created from the given column vectors.
     * @param u first column vector; this corresponds to the first basis vector
     *      in the coordinate frame
     * @param v second column vector; this corresponds to the second basis vector
     *      in the coordinate frame
     * @param w third column vector; this corresponds to the third basis vector
     *      in the coordinate frame
     * @param t fourth column vector; this corresponds to the translation of the transform
     * @return a new transform with the given column vectors
     */
    public static AffineTransformMatrix3D fromColumnVectors(final Vector3D u, final Vector3D v,
            final Vector3D w, final Vector3D t) {

<span class="fc" id="L666">        return new AffineTransformMatrix3D(</span>
<span class="fc" id="L667">                    u.getX(), v.getX(), w.getX(), t.getX(),</span>
<span class="fc" id="L668">                    u.getY(), v.getY(), w.getY(), t.getY(),</span>
<span class="fc" id="L669">                    u.getZ(), v.getZ(), w.getZ(), t.getZ()</span>
                );
    }

    /** Get the transform representing the identity matrix. This transform does not
     * modify point or vector values when applied.
     * @return transform representing the identity matrix
     */
    public static AffineTransformMatrix3D identity() {
<span class="fc" id="L678">        return IDENTITY_INSTANCE;</span>
    }

    /** Create a transform representing the given translation.
     * @param translation vector containing translation values for each axis
     * @return a new transform representing the given translation
     */
    public static AffineTransformMatrix3D createTranslation(final Vector3D translation) {
<span class="fc" id="L686">        return createTranslation(translation.getX(), translation.getY(), translation.getZ());</span>
    }

    /** Create a transform representing the given translation.
     * @param x translation in the x direction
     * @param y translation in the y direction
     * @param z translation in the z direction
     * @return a new transform representing the given translation
     */
    public static AffineTransformMatrix3D createTranslation(final double x, final double y, final double z) {
<span class="fc" id="L696">        return new AffineTransformMatrix3D(</span>
                    1, 0, 0, x,
                    0, 1, 0, y,
                    0, 0, 1, z
                );
    }

    /** Create a transform representing a scale operation with the given scale factor applied to all axes.
     * @param factor scale factor to apply to all axes
     * @return a new transform representing a uniform scaling in all axes
     */
    public static AffineTransformMatrix3D createScale(final double factor) {
<span class="fc" id="L708">        return createScale(factor, factor, factor);</span>
    }

    /** Create a transform representing a scale operation.
     * @param factors vector containing scale factors for each axis
     * @return a new transform representing a scale operation
     */
    public static AffineTransformMatrix3D createScale(final Vector3D factors) {
<span class="fc" id="L716">        return createScale(factors.getX(), factors.getY(), factors.getZ());</span>
    }

    /** Create a transform representing a scale operation.
     * @param x scale factor for the x axis
     * @param y scale factor for the y axis
     * @param z scale factor for the z axis
     * @return a new transform representing a scale operation
     */
    public static AffineTransformMatrix3D createScale(final double x, final double y, final double z) {
<span class="fc" id="L726">        return new AffineTransformMatrix3D(</span>
                    x, 0, 0, 0,
                    0, y, 0, 0,
                    0, 0, z, 0
                );
    }

    /** Create a transform representing a rotation about the given center point. This is achieved by translating
     * the center to the origin, applying the rotation, and then translating back.
     * @param center the center of rotation
     * @param rotation the rotation to apply
     * @return a new transform representing a rotation about the given center point
     * @see QuaternionRotation#toMatrix()
     */
    public static AffineTransformMatrix3D createRotation(final Vector3D center, final QuaternionRotation rotation) {
<span class="fc" id="L741">        return createTranslation(center.negate())</span>
<span class="fc" id="L742">                .rotate(rotation)</span>
<span class="fc" id="L743">                .translate(center);</span>
    }

    /** Multiply two transform matrices together and return the result as a new transform instance.
     * @param a first transform
     * @param b second transform
     * @return the transform computed as {@code a x b}
     */
    private static AffineTransformMatrix3D multiply(final AffineTransformMatrix3D a,
            final AffineTransformMatrix3D b) {

        // calculate the matrix elements
<span class="fc" id="L755">        final double c00 = Vectors.linearCombination(a.m00, b.m00, a.m01, b.m10, a.m02, b.m20);</span>
<span class="fc" id="L756">        final double c01 = Vectors.linearCombination(a.m00, b.m01, a.m01, b.m11, a.m02, b.m21);</span>
<span class="fc" id="L757">        final double c02 = Vectors.linearCombination(a.m00, b.m02, a.m01, b.m12, a.m02, b.m22);</span>
<span class="fc" id="L758">        final double c03 = Vectors.linearCombination(a.m00, b.m03, a.m01, b.m13, a.m02, b.m23) + a.m03;</span>

<span class="fc" id="L760">        final double c10 = Vectors.linearCombination(a.m10, b.m00, a.m11, b.m10, a.m12, b.m20);</span>
<span class="fc" id="L761">        final double c11 = Vectors.linearCombination(a.m10, b.m01, a.m11, b.m11, a.m12, b.m21);</span>
<span class="fc" id="L762">        final double c12 = Vectors.linearCombination(a.m10, b.m02, a.m11, b.m12, a.m12, b.m22);</span>
<span class="fc" id="L763">        final double c13 = Vectors.linearCombination(a.m10, b.m03, a.m11, b.m13, a.m12, b.m23) + a.m13;</span>

<span class="fc" id="L765">        final double c20 = Vectors.linearCombination(a.m20, b.m00, a.m21, b.m10, a.m22, b.m20);</span>
<span class="fc" id="L766">        final double c21 = Vectors.linearCombination(a.m20, b.m01, a.m21, b.m11, a.m22, b.m21);</span>
<span class="fc" id="L767">        final double c22 = Vectors.linearCombination(a.m20, b.m02, a.m21, b.m12, a.m22, b.m22);</span>
<span class="fc" id="L768">        final double c23 = Vectors.linearCombination(a.m20, b.m03, a.m21, b.m13, a.m22, b.m23) + a.m23;</span>

<span class="fc" id="L770">        return new AffineTransformMatrix3D(</span>
                    c00, c01, c02, c03,
                    c10, c11, c12, c13,
                    c20, c21, c22, c23
                );
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>