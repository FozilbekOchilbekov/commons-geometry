<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>QuaternionRotation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.threed.rotation</a> &gt; <span class="el_source">QuaternionRotation.java</span></div><h1>QuaternionRotation.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.threed.rotation;

import java.util.Objects;
import java.util.function.DoubleFunction;

import org.apache.commons.geometry.core.internal.GeometryInternalError;
import org.apache.commons.geometry.euclidean.internal.Vectors;
import org.apache.commons.geometry.euclidean.threed.AffineTransformMatrix3D;
import org.apache.commons.geometry.euclidean.threed.Vector3D;
import org.apache.commons.numbers.angle.Angle;
import org.apache.commons.numbers.quaternion.Quaternion;
import org.apache.commons.numbers.quaternion.Slerp;

/**
 * Class using a unit-length quaternion to represent
 * &lt;a href=&quot;https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation&quot;&gt;rotations&lt;/a&gt;
 * in 3-dimensional Euclidean space.
 * The underlying quaternion is in &lt;em&gt;positive polar form&lt;/em&gt;: It is normalized and has a
 * non-negative scalar component ({@code w}).
 *
 * @see Quaternion
 */
public final class QuaternionRotation implements Rotation3D {
    /** Threshold value for the dot product of antiparallel vectors. If the dot product of two vectors is
     * less than this value, (adjusted for the lengths of the vectors), then the vectors are considered to be
     * antiparallel (ie, negations of each other).
     */
    private static final double ANTIPARALLEL_DOT_THRESHOLD = 2.0e-15 - 1.0;

    /** Threshold value used to identify singularities when converting from quaternions to
     * axis angle sequences.
     */
    private static final double AXIS_ANGLE_SINGULARITY_THRESHOLD = 0.9999999999;

    /** Instance used to represent the identity rotation, ie a rotation with
     * an angle of zero.
     */
<span class="fc" id="L54">    private static final QuaternionRotation IDENTITY_INSTANCE = of(Quaternion.ONE);</span>

    /** Unit-length quaternion instance in positive polar form. */
    private final Quaternion quat;

    /** Simple constructor. The given quaternion is converted to positive polar form.
     * @param quat quaternion instance
     * @throws IllegalStateException if the norm of the given components is zero,
     *                              NaN, or infinite
     */
<span class="fc" id="L64">    private QuaternionRotation(final Quaternion quat) {</span>
<span class="fc" id="L65">        this.quat = quat.positivePolarForm();</span>
<span class="fc" id="L66">    }</span>

    /** Get the underlying quaternion instance.
     * @return the quaternion instance
     */
    public Quaternion getQuaternion() {
<span class="fc" id="L72">        return quat;</span>
    }

    /**
     * Get the axis of rotation as a normalized {@link Vector3D}. The rotation axis
     * is not well defined when the rotation is the identity rotation, ie it has a
     * rotation angle of zero. In this case, the vector representing the positive
     * x-axis is returned.
     *
     * @return the axis of rotation
     */
    @Override
    public Vector3D getAxis() {
<span class="fc" id="L85">        final Vector3D axis = Vector3D.of(quat.getX(), quat.getY(), quat.getZ())</span>
<span class="fc" id="L86">                .normalizeOrNull();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        return axis != null ?</span>
<span class="fc" id="L88">                axis :</span>
<span class="fc" id="L89">                Vector3D.Unit.PLUS_X;</span>
    }

    /**
     * Get the angle of rotation in radians. The returned value is in the range 0
     * through {@code pi}.
     *
     * @return The rotation angle in the range {@code [0, pi]}.
     */
    @Override
    public double getAngle() {
<span class="fc" id="L100">        return 2 * Math.acos(quat.getW());</span>
    }

    /**
     * Get the inverse of this rotation. The returned rotation has the same
     * rotation angle but the opposite rotation axis. If {@code r.apply(u)}
     * is equal to {@code v}, then {@code r.negate().apply(v)} is equal
     * to {@code u}.
     *
     * @return the negation (inverse) of the rotation
     */
    @Override
    public QuaternionRotation inverse() {
<span class="fc" id="L113">        return new QuaternionRotation(quat.conjugate());</span>
    }

    /**
     * Apply this rotation to the given vector.
     *
     * @param v vector to rotate
     * @return the rotated vector
     */
    @Override
    public Vector3D apply(final Vector3D v) {
<span class="fc" id="L124">        final double qw = quat.getW();</span>
<span class="fc" id="L125">        final double qx = quat.getX();</span>
<span class="fc" id="L126">        final double qy = quat.getY();</span>
<span class="fc" id="L127">        final double qz = quat.getZ();</span>

<span class="fc" id="L129">        final double x = v.getX();</span>
<span class="fc" id="L130">        final double y = v.getY();</span>
<span class="fc" id="L131">        final double z = v.getZ();</span>

        // calculate the Hamilton product of the quaternion and vector
<span class="fc" id="L134">        final double iw = -(qx * x) - (qy * y) - (qz * z);</span>
<span class="fc" id="L135">        final double ix = (qw * x) + (qy * z) - (qz * y);</span>
<span class="fc" id="L136">        final double iy = (qw * y) + (qz * x) - (qx * z);</span>
<span class="fc" id="L137">        final double iz = (qw * z) + (qx * y) - (qy * x);</span>

        // calculate the Hamilton product of the intermediate vector and
        // the inverse quaternion

<span class="fc" id="L142">        return Vector3D.of(</span>
                    (iw * -qx) + (ix * qw) + (iy * -qz) - (iz * -qy),
                    (iw * -qy) - (ix * -qz) + (iy * qw) + (iz * -qx),
                    (iw * -qz) + (ix * -qy) - (iy * -qx) + (iz * qw)
                );
    }

    /** {@inheritDoc}
     *
     * &lt;p&gt;This method simply calls {@code apply(vec)} since rotations treat
     * points and vectors similarly.&lt;/p&gt;
     */
    @Override
    public Vector3D applyVector(final Vector3D vec) {
<span class="fc" id="L156">        return apply(vec);</span>
    }

    /** {@inheritDoc}
     *
     * &lt;p&gt;This method simply returns true since rotations always preserve the orientation
     * of the space.&lt;/p&gt;
     */
    @Override
    public boolean preservesOrientation() {
<span class="fc" id="L166">        return true;</span>
    }

    /** Return an {@link AffineTransformMatrix3D} representing the same rotation as this
     * instance.
     * @return a transform matrix representing the same rotation as this instance
     */
    public AffineTransformMatrix3D toMatrix() {

<span class="fc" id="L175">        final double qw = quat.getW();</span>
<span class="fc" id="L176">        final double qx = quat.getX();</span>
<span class="fc" id="L177">        final double qy = quat.getY();</span>
<span class="fc" id="L178">        final double qz = quat.getZ();</span>

        // pre-calculate products that we'll need
<span class="fc" id="L181">        final double xx = qx * qx;</span>
<span class="fc" id="L182">        final double xy = qx * qy;</span>
<span class="fc" id="L183">        final double xz = qx * qz;</span>
<span class="fc" id="L184">        final double xw = qx * qw;</span>

<span class="fc" id="L186">        final double yy = qy * qy;</span>
<span class="fc" id="L187">        final double yz = qy * qz;</span>
<span class="fc" id="L188">        final double yw = qy * qw;</span>

<span class="fc" id="L190">        final double zz = qz * qz;</span>
<span class="fc" id="L191">        final double zw = qz * qw;</span>

<span class="fc" id="L193">        final double m00 = 1.0 - (2.0 * (yy + zz));</span>
<span class="fc" id="L194">        final double m01 = 2.0 * (xy - zw);</span>
<span class="fc" id="L195">        final double m02 = 2.0 * (xz + yw);</span>
<span class="fc" id="L196">        final double m03 = 0.0;</span>

<span class="fc" id="L198">        final double m10 = 2.0 * (xy + zw);</span>
<span class="fc" id="L199">        final double m11 = 1.0 - (2.0 * (xx + zz));</span>
<span class="fc" id="L200">        final double m12 = 2.0 * (yz - xw);</span>
<span class="fc" id="L201">        final double m13 = 0.0;</span>

<span class="fc" id="L203">        final double m20 = 2.0 * (xz - yw);</span>
<span class="fc" id="L204">        final double m21 = 2.0 * (yz + xw);</span>
<span class="fc" id="L205">        final double m22 = 1.0 - (2.0 * (xx + yy));</span>
<span class="fc" id="L206">        final double m23 = 0.0;</span>

<span class="fc" id="L208">        return AffineTransformMatrix3D.of(</span>
                    m00, m01, m02, m03,
                    m10, m11, m12, m13,
                    m20, m21, m22, m23
                );
    }

    /**
     * Multiply this instance by the given argument, returning the result as
     * a new instance. This is equivalent to the expression {@code t * q} where
     * {@code q} is the argument and {@code t} is this instance.
     *
     * &lt;p&gt;
     * Multiplication of quaternions behaves similarly to transformation
     * matrices in regard to the order that operations are performed.
     * For example, if &lt;code&gt;q&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; and &lt;code&gt;q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; are unit
     * quaternions, then the quaternion &lt;code&gt;q&lt;sub&gt;r&lt;/sub&gt; = q&lt;sub&gt;1&lt;/sub&gt;*q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;
     * will give the effect of applying the rotation in &lt;code&gt;q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; followed
     * by the rotation in &lt;code&gt;q&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;. In other words, the rightmost element
     * in the multiplication is applied first.
     * &lt;/p&gt;
     *
     * @param q quaternion to multiply with the current instance
     * @return the result of multiplying this quaternion by the argument
     */
    public QuaternionRotation multiply(final QuaternionRotation q) {
<span class="fc" id="L234">        final Quaternion product = quat.multiply(q.quat);</span>
<span class="fc" id="L235">        return new QuaternionRotation(product);</span>
    }

    /** Multiply the argument by this instance, returning the result as
     * a new instance. This is equivalent to the expression {@code q * t} where
     * {@code q} is the argument and {@code t} is this instance.
     *
     * &lt;p&gt;
     * Multiplication of quaternions behaves similarly to transformation
     * matrices in regard to the order that operations are performed.
     * For example, if &lt;code&gt;q&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt; and &lt;code&gt;q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; are unit
     * quaternions, then the quaternion &lt;code&gt;q&lt;sub&gt;r&lt;/sub&gt; = q&lt;sub&gt;1&lt;/sub&gt;*q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt;
     * will give the effect of applying the rotation in &lt;code&gt;q&lt;sub&gt;2&lt;/sub&gt;&lt;/code&gt; followed
     * by the rotation in &lt;code&gt;q&lt;sub&gt;1&lt;/sub&gt;&lt;/code&gt;. In other words, the rightmost element
     * in the multiplication is applied first.
     * &lt;/p&gt;
     *
     * @param q quaternion to multiply by the current instance
     * @return the result of multiplying the argument by the current instance
     */
    public QuaternionRotation premultiply(final QuaternionRotation q) {
<span class="fc" id="L256">        return q.multiply(this);</span>
    }

    /**
     * Creates a function that performs a
     * &lt;a href=&quot;https://en.wikipedia.org/wiki/Slerp&quot;&gt;spherical
     * linear interpolation&lt;/a&gt; between this instance and the argument.
     * &lt;p&gt;
     * The argument to the function returned by this method is the
     * interpolation parameter {@code t}.
     * If {@code t = 0}, the rotation is equal to this instance.
     * If {@code t = 1}, the rotation is equal to the {@code end} instance.
     * All other values are interpolated (or extrapolated if {@code t} is
     * outside of the {@code [0, 1]} range).
     *
     * @param end end value of the interpolation
     * @return a function that interpolates between this instance and the
     * argument.
     *
     * @see org.apache.commons.numbers.quaternion.Slerp
     */
    public DoubleFunction&lt;QuaternionRotation&gt; slerp(final QuaternionRotation end) {
<span class="fc" id="L278">        final Slerp s = new Slerp(getQuaternion(), end.getQuaternion());</span>
<span class="fc" id="L279">        return t -&gt; QuaternionRotation.of(s.apply(t));</span>
    }

    /** Get a sequence of axis-angle rotations that produce an overall rotation equivalent to this instance.
     *
     * &lt;p&gt;
     * In most cases, the returned rotation sequence will be unique. However, at points of singularity
     * (second angle equal to {@code 0} or {@code -pi} for Euler angles and {@code +pi/2} or {@code -pi/2}
     * for Tait-Bryan angles), there are an infinite number of possible sequences that produce the same result.
     * In these cases, the result is returned that leaves the last rotation equal to 0 (in the case of a relative
     * reference frame) or the first rotation equal to 0 (in the case of an absolute reference frame).
     * &lt;/p&gt;
     *
     * @param frame the reference frame used to interpret the positions of the rotation axes
     * @param axes the sequence of rotation axes
     * @return a sequence of axis-angle rotations equivalent to this rotation
     */
    public AxisAngleSequence toAxisAngleSequence(final AxisReferenceFrame frame, final AxisSequence axes) {
<span class="fc bfc" id="L297" title="All 2 branches covered.">        if (frame == null) {</span>
<span class="fc" id="L298">            throw new IllegalArgumentException(&quot;Axis reference frame cannot be null&quot;);</span>
        }
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (axes == null) {</span>
<span class="fc" id="L301">            throw new IllegalArgumentException(&quot;Axis sequence cannot be null&quot;);</span>
        }

<span class="fc" id="L304">        final double[] angles = getAngles(frame, axes);</span>

<span class="fc" id="L306">        return new AxisAngleSequence(frame, axes, angles[0], angles[1], angles[2]);</span>
    }

    /** Get a sequence of axis-angle rotations that produce an overall rotation equivalent to this instance.
     * Each rotation axis is interpreted relative to the rotated coordinate frame (ie, intrinsic rotation).
     * @param axes the sequence of rotation axes
     * @return a sequence of relative axis-angle rotations equivalent to this rotation
     * @see #toAxisAngleSequence(AxisReferenceFrame, AxisSequence)
     */
    public AxisAngleSequence toRelativeAxisAngleSequence(final AxisSequence axes) {
<span class="fc" id="L316">        return toAxisAngleSequence(AxisReferenceFrame.RELATIVE, axes);</span>
    }

    /** Get a sequence of axis-angle rotations that produce an overall rotation equivalent to this instance.
     * Each rotation axis is interpreted as part of an absolute, unmoving coordinate frame (ie, extrinsic rotation).
     * @param axes the sequence of rotation axes
     * @return a sequence of absolute axis-angle rotations equivalent to this rotation
     * @see #toAxisAngleSequence(AxisReferenceFrame, AxisSequence)
     */
    public AxisAngleSequence toAbsoluteAxisAngleSequence(final AxisSequence axes) {
<span class="fc" id="L326">        return toAxisAngleSequence(AxisReferenceFrame.ABSOLUTE, axes);</span>
    }

    /** {@inheritDoc} */
    @Override
    public int hashCode() {
<span class="fc" id="L332">        return quat.hashCode();</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean equals(final Object obj) {
<span class="fc bfc" id="L338" title="All 2 branches covered.">        if (this == obj) {</span>
<span class="fc" id="L339">            return true;</span>
        }
<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (!(obj instanceof QuaternionRotation)) {</span>
<span class="fc" id="L342">            return false;</span>
        }

<span class="fc" id="L345">        final QuaternionRotation other = (QuaternionRotation) obj;</span>
<span class="fc" id="L346">        return Objects.equals(this.quat, other.quat);</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {
<span class="fc" id="L352">        return quat.toString();</span>
    }

    /** Get a sequence of angles around the given axes that produce a rotation equivalent
     * to this instance.
     * @param frame the reference frame used to define the positions of the axes
     * @param axes the axis sequence
     * @return a sequence of angles around the given axes that produce a rotation equivalent
     *      to this instance
     */
    private double[] getAngles(final AxisReferenceFrame frame, final AxisSequence axes) {

<span class="fc" id="L364">        final AxisSequenceType sequenceType = axes.getType();</span>

<span class="fc" id="L366">        final Vector3D axis1 = axes.getAxis1();</span>
<span class="fc" id="L367">        final Vector3D axis2 = axes.getAxis2();</span>
<span class="fc" id="L368">        final Vector3D axis3 = axes.getAxis3();</span>

<span class="fc bfc" id="L370" title="All 2 branches covered.">        if (frame == AxisReferenceFrame.RELATIVE) {</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">            if (sequenceType == AxisSequenceType.TAIT_BRYAN) {</span>
<span class="fc" id="L372">                return getRelativeTaitBryanAngles(axis1, axis2, axis3);</span>
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">            } else if (sequenceType == AxisSequenceType.EULER) {</span>
<span class="fc" id="L374">                return getRelativeEulerAngles(axis1, axis2);</span>
            }
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">        } else if (frame == AxisReferenceFrame.ABSOLUTE) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">            if (sequenceType == AxisSequenceType.TAIT_BRYAN) {</span>
<span class="fc" id="L378">                return getAbsoluteTaitBryanAngles(axis1, axis2, axis3);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            } else if (sequenceType == AxisSequenceType.EULER) {</span>
<span class="fc" id="L380">                return getAbsoluteEulerAngles(axis1, axis2);</span>
            }
        }

        // all possibilities should have been covered above
<span class="nc" id="L385">        throw new GeometryInternalError();</span>
    }

    /** Get a sequence of angles around the given Tait-Bryan axes that produce a rotation equivalent
     * to this instance. The axes are interpreted as being relative to the rotated coordinate frame.
     * @param axis1 first Tait-Bryan axis
     * @param axis2 second Tait-Bryan axis
     * @param axis3 third Tait-Bryan axis
     * @return a sequence of rotation angles around the relative input axes that produce a rotation equivalent
     *      to this instance
     */
    private double[] getRelativeTaitBryanAngles(final Vector3D axis1, final Vector3D axis2, final Vector3D axis3) {

        // We can use geometry to get the first and second angles pretty easily here by analyzing the positions
        // of the transformed rotation axes. The third angle is trickier but we can get it by treating it as
        // if it were the first rotation in the inverse (which it would be).

<span class="fc" id="L402">        final Vector3D vec3 = apply(axis3);</span>
<span class="fc" id="L403">        final Vector3D invVec1 = inverse().apply(axis1);</span>

<span class="fc" id="L405">        final double angle2Sin = vec3.dot(axis2.cross(axis3));</span>

<span class="fc bfc" id="L407" title="All 4 branches covered.">        if (angle2Sin &lt; -AXIS_ANGLE_SINGULARITY_THRESHOLD ||</span>
                angle2Sin &gt; AXIS_ANGLE_SINGULARITY_THRESHOLD) {

<span class="fc" id="L410">            final Vector3D vec2 = apply(axis2);</span>

<span class="fc" id="L412">            final double angle1TanY = vec2.dot(axis1.cross(axis2));</span>
<span class="fc" id="L413">            final double angle1TanX = vec2.dot(axis2);</span>

<span class="fc bfc" id="L415" title="All 2 branches covered.">            final double angle2 = angle2Sin &gt; AXIS_ANGLE_SINGULARITY_THRESHOLD ?</span>
<span class="fc" id="L416">                    Angle.PI_OVER_TWO :</span>
<span class="fc" id="L417">                    -Angle.PI_OVER_TWO;</span>

<span class="fc" id="L419">            return new double[] {</span>
<span class="fc" id="L420">                Math.atan2(angle1TanY, angle1TanX),</span>
                angle2,
                0.0
            };
        }

<span class="fc" id="L426">        final Vector3D  crossAxis13 = axis1.cross(axis3);</span>

<span class="fc" id="L428">        final double angle1TanY = vec3.dot(crossAxis13);</span>
<span class="fc" id="L429">        final double angle1TanX = vec3.dot(axis3);</span>

<span class="fc" id="L431">        final double angle3TanY = invVec1.dot(crossAxis13);</span>
<span class="fc" id="L432">        final double angle3TanX = invVec1.dot(axis1);</span>

<span class="fc" id="L434">        return new double[] {</span>
<span class="fc" id="L435">            Math.atan2(angle1TanY, angle1TanX),</span>
<span class="fc" id="L436">            Math.asin(angle2Sin),</span>
<span class="fc" id="L437">            Math.atan2(angle3TanY, angle3TanX)</span>
        };
    }

    /** Get a sequence of angles around the given Tait-Bryan axes that produce a rotation equivalent
     * to this instance. The axes are interpreted as being part of an absolute (unmoving) coordinate frame.
     * @param axis1 first Tait-Bryan axis
     * @param axis2 second Tait-Bryan axis
     * @param axis3 third Tait-Bryan axis
     * @return a sequence of rotation angles around the absolute input axes that produce a rotation equivalent
     *      to this instance
     */
    private double[] getAbsoluteTaitBryanAngles(final Vector3D axis1, final Vector3D axis2, final Vector3D axis3) {
        // A relative axis-angle rotation sequence is equivalent to an absolute one with the rotation
        // sequence reversed, meaning we can reuse our relative logic here.
<span class="fc" id="L452">        return reverseArray(getRelativeTaitBryanAngles(axis3, axis2, axis1));</span>
    }

    /** Get a sequence of angles around the given Euler axes that produce a rotation equivalent
     * to this instance. The axes are interpreted as being relative to the rotated coordinate frame. Only
     * the first two axes are needed since, by definition, the first Euler angle axis is repeated as the
     * third axis.
     * @param axis1 first Euler axis
     * @param axis2 second Euler axis
     * @return a sequence of rotation angles around the relative input axes that produce a rotation equivalent
     *      to this instance
     */
    private double[] getRelativeEulerAngles(final Vector3D axis1, final Vector3D axis2) {

        // Use the same overall approach as with the Tait-Bryan angles: get the first two angles by looking
        // at the transformed rotation axes and the third by using the inverse.

<span class="fc" id="L469">        final Vector3D crossAxis = axis1.cross(axis2);</span>

<span class="fc" id="L471">        final Vector3D vec1 = apply(axis1);</span>
<span class="fc" id="L472">        final Vector3D invVec1 = inverse().apply(axis1);</span>

<span class="fc" id="L474">        final double angle2Cos = vec1.dot(axis1);</span>

<span class="fc bfc" id="L476" title="All 4 branches covered.">        if (angle2Cos &lt; -AXIS_ANGLE_SINGULARITY_THRESHOLD ||</span>
                angle2Cos &gt; AXIS_ANGLE_SINGULARITY_THRESHOLD) {

<span class="fc" id="L479">            final Vector3D vec2 = apply(axis2);</span>

<span class="fc" id="L481">            final double angle1TanY = vec2.dot(crossAxis);</span>
<span class="fc" id="L482">            final double angle1TanX = vec2.dot(axis2);</span>

<span class="fc bfc" id="L484" title="All 2 branches covered.">            final double angle2 = angle2Cos &gt; AXIS_ANGLE_SINGULARITY_THRESHOLD ? 0.0 : Math.PI;</span>

<span class="fc" id="L486">            return new double[] {</span>
<span class="fc" id="L487">                Math.atan2(angle1TanY, angle1TanX),</span>
                angle2,
                0.0
            };
        }

<span class="fc" id="L493">        final double angle1TanY = vec1.dot(axis2);</span>
<span class="fc" id="L494">        final double angle1TanX = -vec1.dot(crossAxis);</span>

<span class="fc" id="L496">        final double angle3TanY = invVec1.dot(axis2);</span>
<span class="fc" id="L497">        final double angle3TanX = invVec1.dot(crossAxis);</span>

<span class="fc" id="L499">        return new double[] {</span>
<span class="fc" id="L500">            Math.atan2(angle1TanY, angle1TanX),</span>
<span class="fc" id="L501">            Math.acos(angle2Cos),</span>
<span class="fc" id="L502">            Math.atan2(angle3TanY, angle3TanX)</span>
        };
    }

    /** Get a sequence of angles around the given Euler axes that produce a rotation equivalent
     * to this instance. The axes are interpreted as being part of an absolute (unmoving) coordinate frame.
     * Only the first two axes are needed since, by definition, the first Euler angle axis is repeated as
     * the third axis.
     * @param axis1 first Euler axis
     * @param axis2 second Euler axis
     * @return a sequence of rotation angles around the absolute input axes that produce a rotation equivalent
     *      to this instance
     */
    private double[] getAbsoluteEulerAngles(final Vector3D axis1, final Vector3D axis2) {
        // A relative axis-angle rotation sequence is equivalent to an absolute one with the rotation
        // sequence reversed, meaning we can reuse our relative logic here.
<span class="fc" id="L518">        return reverseArray(getRelativeEulerAngles(axis1, axis2));</span>
    }

    /** Create a new instance from the given quaternion. The quaternion is normalized and
     * converted to positive polar form (ie, with w &amp;gt;= 0).
     *
     * @param quat the quaternion to use for the rotation
     * @return a new instance built from the given quaternion.
     * @throws IllegalStateException if the norm of the given components is zero,
     *                              NaN, or infinite
     * @see Quaternion#normalize()
     * @see Quaternion#positivePolarForm()
     */
    public static QuaternionRotation of(final Quaternion quat) {
<span class="fc" id="L532">        return new QuaternionRotation(quat);</span>
    }

    /**
     * Create a new instance from the given quaternion values. The inputs are
     * normalized and converted to positive polar form (ie, with w &amp;gt;= 0).
     *
     * @param w quaternion scalar component
     * @param x first quaternion vectorial component
     * @param y second quaternion vectorial component
     * @param z third quaternion vectorial component
     * @return a new instance containing the normalized quaterion components
     * @throws IllegalStateException if the norm of the given components is zero,
     *                              NaN, or infinite
     * @see Quaternion#normalize()
     * @see Quaternion#positivePolarForm()
     */
    public static QuaternionRotation of(final double w,
                                        final double x,
                                        final double y,
                                        final double z) {
<span class="fc" id="L553">        return of(Quaternion.of(w, x, y, z));</span>
    }

    /** Return an instance representing a rotation of zero.
     * @return instance representing a rotation of zero.
     */
    public static QuaternionRotation identity() {
<span class="fc" id="L560">        return IDENTITY_INSTANCE;</span>
    }

    /** Create a new instance representing a rotation of {@code angle} radians around
     * {@code axis}.
     *
     * &lt;p&gt;
     * Rotation direction follows the right-hand rule, meaning that if one
     * places their right hand such that the thumb points in the direction of the vector,
     * the curl of the fingers indicates the direction of rotation.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     * Note that the returned quaternion will represent the defined rotation but the values
     * returned by {@link #getAxis()} and {@link #getAngle()} may not match the ones given here.
     * This is because the axis and angle are normalized such that the axis has unit length,
     * and the angle lies in the range {@code [0, pi]}. Depending on the inputs, the axis may
     * need to be inverted in order for the angle to lie in this range.
     * &lt;/p&gt;
     *
     * @param axis the axis of rotation
     * @param angle angle of rotation in radians
     * @return a new instance representing the defined rotation
     *
     * @throws IllegalArgumentException if the given axis cannot be normalized or the angle is NaN or infinite
     */
    public static QuaternionRotation fromAxisAngle(final Vector3D axis, final double angle) {
        // reference formula:
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
<span class="fc" id="L589">        final Vector3D normAxis = axis.normalize();</span>

<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (!Double.isFinite(angle)) {</span>
<span class="fc" id="L592">            throw new IllegalArgumentException(&quot;Invalid angle: &quot; + angle);</span>
        }

<span class="fc" id="L595">        final double halfAngle = 0.5 * angle;</span>
<span class="fc" id="L596">        final double sinHalfAngle = Math.sin(halfAngle);</span>

<span class="fc" id="L598">        final double w = Math.cos(halfAngle);</span>
<span class="fc" id="L599">        final double x = sinHalfAngle * normAxis.getX();</span>
<span class="fc" id="L600">        final double y = sinHalfAngle * normAxis.getY();</span>
<span class="fc" id="L601">        final double z = sinHalfAngle * normAxis.getZ();</span>

<span class="fc" id="L603">        return of(w, x, y, z);</span>
    }

    /** Return an instance that rotates the first vector to the second.
     *
     * &lt;p&gt;Except for a possible scale factor, if the returned instance is
     * applied to vector {@code u}, it will produce the vector {@code v}. There are an
     * infinite number of such rotations; this method chooses the one with the smallest
     * associated angle, meaning the one whose axis is orthogonal to the {@code (u, v)}
     * plane. If {@code u} and {@code v} are collinear, an arbitrary rotation axis is
     * chosen.&lt;/p&gt;
     *
     * @param u origin vector
     * @param v target vector
     * @return a new instance that rotates {@code u} to point in the direction of {@code v}
     * @throws IllegalArgumentException if either vector has a norm of zero, NaN, or infinity
     */
    public static QuaternionRotation createVectorRotation(final Vector3D u, final Vector3D v) {

<span class="fc" id="L622">        final double normProduct  = Vectors.checkedNorm(u) * Vectors.checkedNorm(v);</span>
<span class="fc" id="L623">        final double dot = u.dot(v);</span>

<span class="fc bfc" id="L625" title="All 2 branches covered.">        if (dot &lt; ANTIPARALLEL_DOT_THRESHOLD * normProduct) {</span>
            // Special case where u1 = -u2:
            // create a pi angle rotation around
            // an arbitrary unit vector orthogonal to u1
<span class="fc" id="L629">            final Vector3D axis = u.orthogonal();</span>

<span class="fc" id="L631">            return of(0,</span>
<span class="fc" id="L632">                      axis.getX(),</span>
<span class="fc" id="L633">                      axis.getY(),</span>
<span class="fc" id="L634">                      axis.getZ());</span>
        }

        // General case:
        // (u1, u2) defines a plane so rotate around the normal of the plane

        // w must equal cos(theta/2); we can calculate this directly using values
        // we already have with the identity cos(theta/2) = sqrt((1 + cos(theta)) / 2)
        // and the fact that dot = norm(u1) * norm(u2) * cos(theta).
<span class="fc" id="L643">        final double w = Math.sqrt(0.5 * (1.0 + (dot / normProduct)));</span>

        // The cross product u1 x u2 must be normalized and then multiplied by
        // sin(theta/2) in order to set the vectorial part of the quaternion. To
        // accomplish this, we'll use the following:
        //
        // 1) norm(a x b) = norm(a) * norm(b) * sin(theta)
        // 2) sin(theta/2) = sqrt((1 - cos(theta)) / 2)
        //
        // Our full, combined normalization and sine half angle term factor then becomes:
        //
        // sqrt((1 - cos(theta)) / 2) / (norm(u1) * norm(u2) * sin(theta))
        //
        // This can be simplified to the expression below.
<span class="fc" id="L657">        final double vectorialScaleFactor = 1.0 / (2.0 * w * normProduct);</span>
<span class="fc" id="L658">        final Vector3D axis = u.cross(v);</span>

<span class="fc" id="L660">        return of(w,</span>
<span class="fc" id="L661">                  vectorialScaleFactor * axis.getX(),</span>
<span class="fc" id="L662">                  vectorialScaleFactor * axis.getY(),</span>
<span class="fc" id="L663">                  vectorialScaleFactor * axis.getZ());</span>
    }

    /** Return an instance that rotates the basis defined by the first two vectors into the basis
     * defined by the second two.
     *
     * &lt;p&gt;
     * The given basis vectors do not have to be directly orthogonal. A right-handed orthonormal
     * basis is created from each pair by normalizing the first vector, making the second vector
     * orthogonal to the first, and then taking the cross product. A rotation is then calculated
     * that rotates the first to the second.
     * &lt;/p&gt;
     *
     * @param u1 first vector of the source basis
     * @param u2 second vector of the source basis
     * @param v1 first vector of the target basis
     * @param v2 second vector of the target basis
     * @return an instance that rotates the source basis to the target basis
     * @throws IllegalArgumentException if any of the input vectors cannot be normalized
     *      or the vectors defining either basis are collinear
     */
    public static QuaternionRotation createBasisRotation(final Vector3D u1, final Vector3D u2,
            final Vector3D v1, final Vector3D v2) {

        // calculate orthonormalized bases
<span class="fc" id="L688">        final Vector3D a = u1.normalize();</span>
<span class="fc" id="L689">        final Vector3D b = a.orthogonal(u2);</span>
<span class="fc" id="L690">        final Vector3D c = a.cross(b);</span>

<span class="fc" id="L692">        final Vector3D d = v1.normalize();</span>
<span class="fc" id="L693">        final Vector3D e = d.orthogonal(v2);</span>
<span class="fc" id="L694">        final Vector3D f = d.cross(e);</span>

        // create an orthogonal rotation matrix representing the change of basis; this matrix will
        // be the multiplication of the matrix composed of the column vectors d, e, f and the
        // inverse of the matrix composed of the column vectors a, b, c (which is simply the transpose since
        // it's orthogonal).
<span class="fc" id="L700">        final double m00 = Vectors.linearCombination(d.getX(), a.getX(), e.getX(), b.getX(), f.getX(), c.getX());</span>
<span class="fc" id="L701">        final double m01 = Vectors.linearCombination(d.getX(), a.getY(), e.getX(), b.getY(), f.getX(), c.getY());</span>
<span class="fc" id="L702">        final double m02 = Vectors.linearCombination(d.getX(), a.getZ(), e.getX(), b.getZ(), f.getX(), c.getZ());</span>

<span class="fc" id="L704">        final double m10 = Vectors.linearCombination(d.getY(), a.getX(), e.getY(), b.getX(), f.getY(), c.getX());</span>
<span class="fc" id="L705">        final double m11 = Vectors.linearCombination(d.getY(), a.getY(), e.getY(), b.getY(), f.getY(), c.getY());</span>
<span class="fc" id="L706">        final double m12 = Vectors.linearCombination(d.getY(), a.getZ(), e.getY(), b.getZ(), f.getY(), c.getZ());</span>

<span class="fc" id="L708">        final double m20 = Vectors.linearCombination(d.getZ(), a.getX(), e.getZ(), b.getX(), f.getZ(), c.getX());</span>
<span class="fc" id="L709">        final double m21 = Vectors.linearCombination(d.getZ(), a.getY(), e.getZ(), b.getY(), f.getZ(), c.getY());</span>
<span class="fc" id="L710">        final double m22 = Vectors.linearCombination(d.getZ(), a.getZ(), e.getZ(), b.getZ(), f.getZ(), c.getZ());</span>


<span class="fc" id="L713">        return orthogonalRotationMatrixToQuaternion(</span>
                    m00, m01, m02,
                    m10, m11, m12,
                    m20, m21, m22
                );
    }

    /** Create a new instance equivalent to the given sequence of axis-angle rotations.
     * @param sequence the axis-angle rotation sequence to convert to a quaternion rotation
     * @return instance representing a rotation equivalent to the given axis-angle sequence
     */
    public static QuaternionRotation fromAxisAngleSequence(final AxisAngleSequence sequence) {
<span class="fc" id="L725">        final AxisSequence axes = sequence.getAxisSequence();</span>

<span class="fc" id="L727">        final QuaternionRotation q1 = fromAxisAngle(axes.getAxis1(), sequence.getAngle1());</span>
<span class="fc" id="L728">        final QuaternionRotation q2 = fromAxisAngle(axes.getAxis2(), sequence.getAngle2());</span>
<span class="fc" id="L729">        final QuaternionRotation q3 = fromAxisAngle(axes.getAxis3(), sequence.getAngle3());</span>

<span class="fc bfc" id="L731" title="All 2 branches covered.">        if (sequence.getReferenceFrame() == AxisReferenceFrame.ABSOLUTE) {</span>
<span class="fc" id="L732">            return q3.multiply(q2).multiply(q1);</span>
        }

<span class="fc" id="L735">        return q1.multiply(q2).multiply(q3);</span>
    }

    /** Create an instance from an orthogonal rotation matrix.
     *
     * @param m00 matrix entry &lt;code&gt;m&lt;sub&gt;0,0&lt;/sub&gt;&lt;/code&gt;
     * @param m01 matrix entry &lt;code&gt;m&lt;sub&gt;0,1&lt;/sub&gt;&lt;/code&gt;
     * @param m02 matrix entry &lt;code&gt;m&lt;sub&gt;0,2&lt;/sub&gt;&lt;/code&gt;
     * @param m10 matrix entry &lt;code&gt;m&lt;sub&gt;1,0&lt;/sub&gt;&lt;/code&gt;
     * @param m11 matrix entry &lt;code&gt;m&lt;sub&gt;1,1&lt;/sub&gt;&lt;/code&gt;
     * @param m12 matrix entry &lt;code&gt;m&lt;sub&gt;1,2&lt;/sub&gt;&lt;/code&gt;
     * @param m20 matrix entry &lt;code&gt;m&lt;sub&gt;2,0&lt;/sub&gt;&lt;/code&gt;
     * @param m21 matrix entry &lt;code&gt;m&lt;sub&gt;2,1&lt;/sub&gt;&lt;/code&gt;
     * @param m22 matrix entry &lt;code&gt;m&lt;sub&gt;2,2&lt;/sub&gt;&lt;/code&gt;
     * @return an instance representing the same 3D rotation as the given matrix
     */
    private static QuaternionRotation orthogonalRotationMatrixToQuaternion(
            final double m00, final double m01, final double m02,
            final double m10, final double m11, final double m12,
            final double m20, final double m21, final double m22) {

        // reference formula:
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/

        // The overall approach here is to take the equations for converting a quaternion to
        // a matrix along with the fact that 1 = x^2 + y^2 + z^2 + w^2 for a normalized quaternion
        // and solve for the various terms. This can theoretically be done using just the diagonal
        // terms from the matrix. However, there are a few issues with this:
        // 1) The term that we end up taking the square root of may be negative.
        // 2) It's ambiguous as to whether we should use a plus or minus for the value of the
        //    square root.
        // We'll address these concerns by only calculating a single term from one of the diagonal
        // elements and then calculate the rest from the non-diagonals, which do not involve
        // a square root. This solves the first issue since we can make sure to choose a diagonal
        // element that will not cause us to take a square root of a negative number. The second
        // issue is solved since only the relative signs between the quaternion terms are important
        // (q and -q represent the same 3D rotation). It therefore doesn't matter whether we choose
        // a plus or minus for our initial square root solution.

<span class="fc" id="L774">        final double trace = m00 + m11 + m22;</span>

        final double w;
        final double x;
        final double y;
        final double z;

<span class="fc bfc" id="L781" title="All 2 branches covered.">        if (trace &gt; 0) {</span>
            // let s = 4*w
<span class="fc" id="L783">            final double s = 2.0 * Math.sqrt(1.0 + trace);</span>
<span class="fc" id="L784">            final double sinv = 1.0 / s;</span>

<span class="fc" id="L786">            x = (m21 - m12) * sinv;</span>
<span class="fc" id="L787">            y = (m02 - m20) * sinv;</span>
<span class="fc" id="L788">            z = (m10 - m01) * sinv;</span>
<span class="fc" id="L789">            w = 0.25 * s;</span>
<span class="fc bfc" id="L790" title="All 4 branches covered.">        } else if ((m00 &gt; m11) &amp;&amp; (m00 &gt; m22)) {</span>
            // let s = 4*x
<span class="fc" id="L792">            final double s = 2.0 * Math.sqrt(1.0 + m00 - m11 - m22);</span>
<span class="fc" id="L793">            final double sinv = 1.0 / s;</span>

<span class="fc" id="L795">            x = 0.25 * s;</span>
<span class="fc" id="L796">            y = (m01 + m10) * sinv;</span>
<span class="fc" id="L797">            z = (m02 + m20) * sinv;</span>
<span class="fc" id="L798">            w = (m21 - m12) * sinv;</span>
<span class="fc bfc" id="L799" title="All 2 branches covered.">        } else if (m11 &gt; m22) {</span>
            // let s = 4*y
<span class="fc" id="L801">            final double s = 2.0 * Math.sqrt(1.0 + m11 - m00 - m22);</span>
<span class="fc" id="L802">            final double sinv = 1.0 / s;</span>

<span class="fc" id="L804">            x = (m01 + m10) * sinv;</span>
<span class="fc" id="L805">            y = 0.25 * s;</span>
<span class="fc" id="L806">            z = (m21 + m12) * sinv;</span>
<span class="fc" id="L807">            w = (m02 - m20) * sinv;</span>
<span class="fc" id="L808">        } else {</span>
            // let s = 4*z
<span class="fc" id="L810">            final double s = 2.0 * Math.sqrt(1.0 + m22 - m00 - m11);</span>
<span class="fc" id="L811">            final double sinv = 1.0 / s;</span>

<span class="fc" id="L813">            x = (m02 + m20) * sinv;</span>
<span class="fc" id="L814">            y = (m21 + m12) * sinv;</span>
<span class="fc" id="L815">            z = 0.25 * s;</span>
<span class="fc" id="L816">            w = (m10 - m01) * sinv;</span>
        }

<span class="fc" id="L819">        return of(w, x, y, z);</span>
    }

    /** Reverse the elements in {@code arr}. The array is returned.
     * @param arr the array to reverse
     * @return the input array with the elements reversed
     */
    private static double[] reverseArray(final double[] arr) {

<span class="fc" id="L828">        final int len = arr.length;</span>
        double temp;

        int i;
        int j;

<span class="fc bfc" id="L834" title="All 2 branches covered.">        for (i = 0, j = len - 1; i &lt; len / 2; ++i, --j) {</span>
<span class="fc" id="L835">            temp = arr[i];</span>
<span class="fc" id="L836">            arr[i] = arr[j];</span>
<span class="fc" id="L837">            arr[j] = temp;</span>
        }

<span class="fc" id="L840">        return arr;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>