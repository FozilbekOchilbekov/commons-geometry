<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Circle.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.twod.shape</a> &gt; <span class="el_source">Circle.java</span></div><h1>Circle.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.twod.shape;

import java.text.MessageFormat;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.geometry.core.partitioning.bsp.RegionCutRule;
import org.apache.commons.geometry.euclidean.AbstractNSphere;
import org.apache.commons.geometry.euclidean.twod.Line;
import org.apache.commons.geometry.euclidean.twod.LineConvexSubset;
import org.apache.commons.geometry.euclidean.twod.LinecastPoint2D;
import org.apache.commons.geometry.euclidean.twod.Linecastable2D;
import org.apache.commons.geometry.euclidean.twod.Lines;
import org.apache.commons.geometry.euclidean.twod.PolarCoordinates;
import org.apache.commons.geometry.euclidean.twod.RegionBSPTree2D;
import org.apache.commons.geometry.euclidean.twod.Vector2D;
import org.apache.commons.numbers.angle.Angle;
import org.apache.commons.numbers.core.Precision;

/** Class representing a circle in 2 dimensional Euclidean space.
 */
public final class Circle extends AbstractNSphere&lt;Vector2D&gt; implements Linecastable2D {

    /** Construct a new circle from its component parts.
     * @param center the center of the circle
     * @param radius the circle radius
     * @param precision precision context used to compare floating point numbers
     * @throws IllegalArgumentException if center is not finite or radius is not finite or is
     *      less than or equal to zero as evaluated by the given precision context
     */
    private Circle(final Vector2D center, final double radius, final Precision.DoubleEquivalence precision) {
<span class="fc" id="L49">        super(center, radius, precision);</span>
<span class="fc" id="L50">    }</span>

    /** {@inheritDoc} */
    @Override
    public double getSize() {
<span class="fc" id="L55">        final double r = getRadius();</span>
<span class="fc" id="L56">        return Math.PI * r * r;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double getBoundarySize() {
<span class="fc" id="L62">        return Angle.TWO_PI * getRadius();</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D project(final Vector2D pt) {
<span class="fc" id="L68">        return project(pt, Vector2D.Unit.PLUS_X);</span>
    }

    /** Return a {@link RegionBSPTree2D} representing an approximation of the circle.
     * All points in the approximation are contained in the circle (ie, they lie inside
     * or on the boundary). No guarantees are made regarding the internal structure of
     * the returned tree. Non-boundary split nodes may be used in order to balance the tree
     * and improve performance.
     *
     * &lt;p&gt;Choosing an appropriate number of segments for an approximation is a trade-off
     * between size and accuracy: approximations with large numbers of segments more closely
     * match the geometric properties of the circle but at the cost of using larger tree
     * structures. In general, the smallest number of segments that produces an acceptable
     * result should be used.
     * @param segments number of line segments to use for the boundary of
     *      the circle approximation
     * @return a BSP tree approximation of the circle
     * @throws IllegalArgumentException if {@code segments} is less than 3
     */
    public RegionBSPTree2D toTree(final int segments) {
<span class="fc" id="L88">        return new CircleApproximationBuilder(this, segments).build();</span>
    }

    /** Get the intersections of the given line with this circle. The returned list will
     * contain either 0, 1, or 2 points.
     * &lt;ul&gt;
     *      &lt;li&gt;&lt;strong&gt;2 points&lt;/strong&gt; - The line is a secant line and intersects the circle at two
     *      distinct points. The points are ordered such that the first point in the list is the first point
     *      encountered when traveling in the direction of the line. (In other words, the points are ordered
     *      by increasing abscissa value.)
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;strong&gt;1 point&lt;/strong&gt; - The line is a tangent line and only intersects the circle at a
     *      single point (as evaluated by the circle's precision context).
     *      &lt;/li&gt;
     *      &lt;li&gt;&lt;strong&gt;0 points&lt;/strong&gt; - The line does not intersect the circle.&lt;/li&gt;
     * &lt;/ul&gt;
     * @param line line to intersect with the circle
     * @return a list of intersection points between the given line and this circle
     */
    public List&lt;Vector2D&gt; intersections(final Line line) {
<span class="fc" id="L108">        return intersections(line, Line::abscissa, Line::distance);</span>
    }

    /** Get the first intersection point between the given line and this circle, or null
     * if no such point exists. The &quot;first&quot; intersection point is the first such point
     * encountered when traveling in the direction of the line from infinity.
     * @param line line to intersect with the circle
     * @return the first intersection point between the given line and this instance or
     *      null if no such point exists
     */
    public Vector2D firstIntersection(final Line line) {
<span class="fc" id="L119">        return firstIntersection(line, Line::abscissa, Line::distance);</span>
    }

    /** {@inheritDoc} */
    @Override
    public List&lt;LinecastPoint2D&gt; linecast(final LineConvexSubset segment) {
<span class="fc" id="L125">        return getLinecastStream(segment)</span>
<span class="fc" id="L126">                .collect(Collectors.toList());</span>
    }

    /** {@inheritDoc} */
    @Override
    public LinecastPoint2D linecastFirst(final LineConvexSubset segment) {
<span class="fc" id="L132">        return getLinecastStream(segment)</span>
<span class="fc" id="L133">                .findFirst()</span>
<span class="fc" id="L134">                .orElse(null);</span>
    }

    /** Get a stream containing the linecast intersection points of the given
     * segment with this instance.
     * @param segment segment to intersect against this instance
     * @return a stream containing linecast intersection points
     */
    private Stream&lt;LinecastPoint2D&gt; getLinecastStream(final LineConvexSubset segment) {
<span class="fc" id="L143">        return intersections(segment.getLine()).stream()</span>
<span class="fc" id="L144">            .filter(segment::contains)</span>
<span class="fc" id="L145">            .map(pt -&gt; new LinecastPoint2D(pt, getCenter().directionTo(pt), segment.getLine()));</span>
    }

    /** Construct a circle from a center point and radius.
     * @param center the center point of the circle
     * @param radius the circle radius
     * @param precision precision precision context used to compare floating point numbers
     * @return a circle with the given center and radius
     * @throws IllegalArgumentException if center is not finite or radius is not finite or is
     *      less than or equal to zero as evaluated by the given precision context
     */
    public static Circle from(final Vector2D center, final double radius, final Precision.DoubleEquivalence precision) {
<span class="fc" id="L157">        return new Circle(center, radius, precision);</span>
    }

    /** Class used to build BSP tree circle approximations. Structural BSP tree cuts are
     * used to help balance the tree and improve performance.
     */
    private static class CircleApproximationBuilder {

        /** The minimum number of segments required to create a circle approximation.
         */
        private static final int MIN_SEGMENTS = 3;

        /** Minimum number of line segments in a portion of the approximation in order
         * to allow a structural BSP split.
         */
        private static final int SPLIT_THRESHOLD = 4;

        /** Circle being approximated. */
        private final Circle circle;

        /** Number of boundary segments in the approximation. */
        private final int segments;

        /** Angle delta between vertex points. */
        private final double angleDelta;

        /** Create a new instance for approximating the given circle.
         * @param circle circle to approximate
         * @param segments number of boundary segments in the approximation
         * @throws IllegalArgumentException if {@code segments} is less than 3
         */
<span class="fc" id="L188">        CircleApproximationBuilder(final Circle circle, final int segments) {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">            if (segments &lt; MIN_SEGMENTS) {</span>
<span class="fc" id="L190">                throw new IllegalArgumentException(MessageFormat.format(</span>
                        &quot;Circle approximation segment number must be greater than or equal to {0}; was {1}&quot;,
<span class="fc" id="L192">                        MIN_SEGMENTS, segments));</span>
            }

<span class="fc" id="L195">            this.circle = circle;</span>

<span class="fc" id="L197">            this.segments = segments;</span>
<span class="fc" id="L198">            this.angleDelta = Angle.TWO_PI / segments;</span>
<span class="fc" id="L199">        }</span>

        /** Build the BSP tree circle approximation.
         * @return the BSP tree circle approximation
         */
        public RegionBSPTree2D build() {
<span class="fc" id="L205">            final RegionBSPTree2D tree = RegionBSPTree2D.empty();</span>
<span class="fc" id="L206">            final RegionBSPTree2D.RegionNode2D root = tree.getRoot();</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (segments &lt; SPLIT_THRESHOLD) {</span>
<span class="fc" id="L209">                insert(root, 0, segments);</span>
            } else {
                // split the circle in half (or mostly in half if an odd number of segments)
<span class="fc" id="L212">                final int splitIdx = segments / 2;</span>
<span class="fc" id="L213">                final Vector2D p0 = pointAt(0);</span>
<span class="fc" id="L214">                final Vector2D p1 = pointAt(splitIdx);</span>

<span class="fc" id="L216">                root.cut(Lines.fromPoints(p0, p1, circle.getPrecision()), RegionCutRule.INHERIT);</span>

<span class="fc" id="L218">                splitAndInsert(root.getPlus(), 0, splitIdx);</span>
<span class="fc" id="L219">                splitAndInsert(root.getMinus(), splitIdx, segments);</span>
            }

<span class="fc" id="L222">            return tree;</span>
        }

        /** Split the given node if possible and recursively add boundary segments.
         * @param node current tree node
         * @param startIdx index of the start point for this node's boundary segments
         * @param stopIdx index of the end point for this node's boundary segments
         */
        private void splitAndInsert(final RegionBSPTree2D.RegionNode2D node, final int startIdx, final int stopIdx) {
<span class="fc bfc" id="L231" title="All 2 branches covered.">            if (stopIdx - startIdx &gt;= SPLIT_THRESHOLD) {</span>
<span class="fc" id="L232">                final int splitIdx = ((stopIdx - startIdx + 1) / 2) + startIdx;</span>
<span class="fc" id="L233">                final Vector2D p0 = circle.getCenter();</span>
<span class="fc" id="L234">                final Vector2D p1 = pointAt(splitIdx);</span>

<span class="fc" id="L236">                node.cut(Lines.fromPoints(p0, p1, circle.getPrecision()), RegionCutRule.INHERIT);</span>

<span class="fc" id="L238">                splitAndInsert(node.getPlus(), startIdx, splitIdx);</span>
<span class="fc" id="L239">                splitAndInsert(node.getMinus(), splitIdx, stopIdx);</span>
<span class="fc" id="L240">            } else {</span>
<span class="fc" id="L241">                insert(node, startIdx, stopIdx);</span>
            }
<span class="fc" id="L243">        }</span>

        /** Insert boundary segments into the given node. No structural splits are created.
         * @param node current tree node
         * @param startIdx index of the start point for this node's boundary segments
         * @param stopIdx index of the end point for this node's boundary segments
         */
        private void insert(final RegionBSPTree2D.RegionNode2D node, final int startIdx, final int stopIdx) {

<span class="fc" id="L252">            RegionBSPTree2D.RegionNode2D currNode = node;</span>
            Vector2D currPt;
<span class="fc" id="L254">            Vector2D prevPt = pointAt(startIdx);</span>
<span class="fc bfc" id="L255" title="All 2 branches covered.">            for (int i = startIdx + 1; i &lt;= stopIdx; ++i) {</span>
<span class="fc" id="L256">                currPt = pointAt(i);</span>

<span class="fc" id="L258">                currNode = currNode.cut(Lines.fromPoints(prevPt, currPt, circle.getPrecision()))</span>
<span class="fc" id="L259">                        .getMinus();</span>

<span class="fc" id="L261">                prevPt = currPt;</span>
            }
<span class="fc" id="L263">        }</span>

        /** Get the boundary vertex point at the given index.
         * @param idx vertex point index
         * @return the vertex point at the given index
         */
        private Vector2D pointAt(final int idx) {
<span class="fc" id="L270">            return PolarCoordinates.toCartesian(circle.getRadius(), idx * angleDelta)</span>
<span class="fc" id="L271">                    .add(circle.getCenter());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>