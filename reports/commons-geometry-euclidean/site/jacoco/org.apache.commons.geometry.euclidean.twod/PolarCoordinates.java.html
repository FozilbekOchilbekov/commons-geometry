<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PolarCoordinates.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.twod</a> &gt; <span class="el_source">PolarCoordinates.java</span></div><h1>PolarCoordinates.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.twod;

import org.apache.commons.geometry.core.Spatial;
import org.apache.commons.geometry.core.internal.SimpleTupleFormat;
import org.apache.commons.numbers.angle.Angle;

/** Class representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Polar_coordinate_system&quot;&gt;polar coordinates&lt;/a&gt;
 * in 2 dimensional Euclidean space.
 *
 * &lt;p&gt;Polar coordinates are defined by a distance from a reference point
 * and an angle from a reference direction. The distance value is called
 * the radial coordinate, or &lt;em&gt;radius&lt;/em&gt;, and the angle is called the angular coordinate,
 * or &lt;em&gt;azimuth&lt;/em&gt;. This class follows the standard
 * mathematical convention of using the positive x-axis as the reference
 * direction and measuring positive angles counter-clockwise, toward the
 * positive y-axis. The origin is used as the reference point. Polar coordinate
 * are related to Cartesian coordinates as follows:
 * &lt;pre&gt;
 * x = r * cos(&amp;theta;)
 * y = r * sin(&amp;theta;)
 *
 * r = &amp;radic;(x^2 + y^2)
 * &amp;theta; = atan2(y, x)
 * &lt;/pre&gt;
 * where &lt;em&gt;r&lt;/em&gt; is the radius and &lt;em&gt;&amp;theta;&lt;/em&gt; is the azimuth of the polar coordinates.
 *
 * &lt;p&gt;In order to ensure the uniqueness of coordinate sets, coordinate values
 * are normalized so that {@code radius} is in the range {@code [0, +Infinity)}
 * and {@code azimuth} is in the range {@code [0, 2pi)}.&lt;/p&gt;
 *
 * @see &lt;a href=&quot;https://en.wikipedia.org/wiki/Polar_coordinate_system&quot;&gt;Polar Coordinate System&lt;/a&gt;
 */
public final class PolarCoordinates implements Spatial {
    /** Radius value. */
    private final double radius;

    /** Azimuth angle in radians. */
    private final double azimuth;

    /** Simple constructor. Input values are normalized.
     * @param radius Radius value.
     * @param azimuth Azimuth angle in radians.
     */
<span class="fc" id="L60">    private PolarCoordinates(final double radius, final double azimuth) {</span>
<span class="fc" id="L61">        double rad = radius;</span>
<span class="fc" id="L62">        double az = azimuth;</span>

<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (rad &lt; 0) {</span>
            // negative radius; flip the angles
<span class="fc" id="L66">            rad = Math.abs(radius);</span>
<span class="fc" id="L67">            az += Math.PI;</span>
        }

<span class="fc" id="L70">        this.radius = rad;</span>
<span class="fc" id="L71">        this.azimuth = normalizeAzimuth(az);</span>
<span class="fc" id="L72">    }</span>

    /** Return the radius value. The value will be greater than or equal to 0.
     * @return radius value
     */
    public double getRadius() {
<span class="fc" id="L78">        return radius;</span>
    }

    /** Return the azimuth angle in radians. The value will be
     * in the range {@code [0, 2pi)}.
     * @return azimuth value in radians.
     */
    public double getAzimuth() {
<span class="fc" id="L86">        return azimuth;</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getDimension() {
<span class="fc" id="L92">        return 2;</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isNaN() {
<span class="fc bfc" id="L98" title="All 4 branches covered.">        return Double.isNaN(radius) || Double.isNaN(azimuth);</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isInfinite() {
<span class="fc bfc" id="L104" title="All 6 branches covered.">        return !isNaN() &amp;&amp; (Double.isInfinite(radius) || Double.isInfinite(azimuth));</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isFinite() {
<span class="fc bfc" id="L110" title="All 4 branches covered.">        return Double.isFinite(radius) &amp;&amp; Double.isFinite(azimuth);</span>
    }

    /** Convert this set of polar coordinates to Cartesian coordinates.
     * @return A 2-dimensional vector with an equivalent set of
     *      coordinates in Cartesian form
     */
    public Vector2D toCartesian() {
<span class="fc" id="L118">        return toCartesian(radius, azimuth);</span>
    }

    /** Get a hashCode for this set of polar coordinates.
     * &lt;p&gt;All NaN values have the same hash code.&lt;/p&gt;
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L128" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L129">            return 191;</span>
        }
<span class="fc" id="L131">        return 449 * (76 * Double.hashCode(radius) + Double.hashCode(azimuth));</span>
    }

    /** Test for the equality of two sets of polar coordinates.
     * &lt;p&gt;
     * If all values of two sets of coordinates are exactly the same, and none are
     * &lt;code&gt;Double.NaN&lt;/code&gt;, the two sets are considered to be equal.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;code&gt;NaN&lt;/code&gt; values are considered to globally affect the coordinates
     * and be equal to each other - i.e, if either (or all) values of the
     * coordinate set are equal to &lt;code&gt;Double.NaN&lt;/code&gt;, the set as a whole is
     * considered to equal &lt;code&gt;NaN&lt;/code&gt;.
     * &lt;/p&gt;
     *
     * @param other Object to test for equality to this
     * @return true if two PolarCoordinates objects are equal, false if
     *         object is null, not an instance of PolarCoordinates, or
     *         not equal to this PolarCoordinates instance
     *
     */
    @Override
    public boolean equals(final Object other) {
<span class="fc bfc" id="L154" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L155">            return true;</span>
        }
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (other instanceof PolarCoordinates) {</span>
<span class="fc" id="L158">            final PolarCoordinates rhs = (PolarCoordinates) other;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (rhs.isNaN()) {</span>
<span class="fc" id="L160">                return this.isNaN();</span>
            }

<span class="fc bfc" id="L163" title="All 2 branches covered.">            return Double.compare(radius, rhs.radius) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">                    Double.compare(azimuth, rhs.azimuth) == 0;</span>
        }
<span class="fc" id="L166">        return false;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {
<span class="fc" id="L172">        return SimpleTupleFormat.getDefault().format(radius, azimuth);</span>
    }

    /** Return a new instance with the given polar coordinate values.
     * The values are normalized so that {@code radius} lies in the range {@code [0, +Infinity)}
     * and {@code azimuth} in the range {@code [0, 2pi)}.
     * @param radius Radius value.
     * @param azimuth Azimuth angle in radians.
     * @return new {@link PolarCoordinates} instance
     */
    public static PolarCoordinates of(final double radius, final double azimuth) {
<span class="fc" id="L183">        return new PolarCoordinates(radius, azimuth);</span>
    }

    /** Convert the given Cartesian coordinates to polar form.
     * @param x X coordinate value
     * @param y Y coordinate value
     * @return polar coordinates equivalent to the given Cartesian coordinates
     */
    public static PolarCoordinates fromCartesian(final double x, final double y) {
<span class="fc" id="L192">        final double azimuth = Math.atan2(y, x);</span>
<span class="fc" id="L193">        final double radius = Math.hypot(x, y);</span>

<span class="fc" id="L195">        return new PolarCoordinates(radius, azimuth);</span>
    }

    /** Convert the given Cartesian coordinates to polar form.
     * @param vec vector containing Cartesian coordinates
     * @return polar coordinates equivalent to the given Cartesian coordinates
     */
    public static PolarCoordinates fromCartesian(final Vector2D vec) {
<span class="fc" id="L203">        return fromCartesian(vec.getX(), vec.getY());</span>
    }

    /** Convert the given polar coordinates to Cartesian form.
     * @param radius Radius value.
     * @param azimuth Azimuth angle in radians.
     * @return A 2-dimensional vector with an equivalent set of
     *      coordinates in Cartesian form
     */
    public static Vector2D toCartesian(final double radius, final double azimuth) {
<span class="fc" id="L213">        final double x = radius * Math.cos(azimuth);</span>
<span class="fc" id="L214">        final double y = radius * Math.sin(azimuth);</span>

<span class="fc" id="L216">        return Vector2D.of(x, y);</span>
    }

    /** Parse the given string and return a new polar coordinates instance. The parsed
     * coordinates are normalized as in the {@link #of(double, double)} method. The expected string
     * format is the same as that returned by {@link #toString()}.
     * @param input the string to parse
     * @return new {@link PolarCoordinates} instance
     * @throws IllegalArgumentException if the string format is invalid.
     */
    public static PolarCoordinates parse(final String input) {
<span class="fc" id="L227">        return SimpleTupleFormat.getDefault().parse(input, PolarCoordinates::new);</span>
    }

    /** Normalize an azimuth value to be within the range {@code [0, 2pi)}.
     * @param azimuth azimuth value in radians
     * @return equivalent azimuth value in the range {@code [0, 2pi)}.
     */
    public static double normalizeAzimuth(final double azimuth) {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        if (Double.isFinite(azimuth)) {</span>
<span class="fc" id="L236">            return Angle.Rad.WITHIN_0_AND_2PI.applyAsDouble(azimuth);</span>
        }

<span class="fc" id="L239">        return azimuth;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>