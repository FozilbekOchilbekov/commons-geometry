<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ru"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Vector2D.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Geometry Euclidean</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.geometry.euclidean.twod</a> &gt; <span class="el_source">Vector2D.java</span></div><h1>Vector2D.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.geometry.euclidean.twod;

import java.util.Arrays;
import java.util.Comparator;
import java.util.Iterator;
import java.util.function.UnaryOperator;

import org.apache.commons.geometry.core.internal.DoubleFunction2N;
import org.apache.commons.geometry.core.internal.SimpleTupleFormat;
import org.apache.commons.geometry.euclidean.EuclideanVectorSum;
import org.apache.commons.geometry.euclidean.MultiDimensionalEuclideanVector;
import org.apache.commons.geometry.euclidean.internal.Vectors;
import org.apache.commons.numbers.core.Precision;

/** This class represents vectors and points in two-dimensional Euclidean space.
 * Instances of this class are guaranteed to be immutable.
 */
public class Vector2D extends MultiDimensionalEuclideanVector&lt;Vector2D&gt; {

    /** Zero vector (coordinates: 0, 0). */
<span class="fc" id="L37">    public static final Vector2D ZERO = new Vector2D(0, 0);</span>

    /** A vector with all coordinates set to NaN. */
<span class="fc" id="L40">    public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);</span>

    /** A vector with all coordinates set to positive infinity. */
<span class="fc" id="L43">    public static final Vector2D POSITIVE_INFINITY =</span>
        new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);

    /** A vector with all coordinates set to negative infinity. */
<span class="fc" id="L47">    public static final Vector2D NEGATIVE_INFINITY =</span>
        new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);

    /** Comparator that sorts vectors in component-wise ascending order.
     * Vectors are only considered equal if their coordinates match exactly.
     * Null arguments are evaluated as being greater than non-null arguments.
     */
<span class="fc" id="L54">    public static final Comparator&lt;Vector2D&gt; COORDINATE_ASCENDING_ORDER = (a, b) -&gt; {</span>
<span class="fc" id="L55">        int cmp = 0;</span>

<span class="fc bfc" id="L57" title="All 4 branches covered.">        if (a != null &amp;&amp; b != null) {</span>
<span class="fc" id="L58">            cmp = Double.compare(a.getX(), b.getX());</span>
<span class="fc bfc" id="L59" title="All 2 branches covered.">            if (cmp == 0) {</span>
<span class="fc" id="L60">                cmp = Double.compare(a.getY(), b.getY());</span>
            }
<span class="fc bfc" id="L62" title="All 2 branches covered.">        } else if (a != null) {</span>
<span class="fc" id="L63">            cmp = -1;</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        } else if (b != null) {</span>
<span class="fc" id="L65">            cmp = 1;</span>
        }

<span class="fc" id="L68">        return cmp;</span>
    };

    /** Abscissa (first coordinate). */
    private final double x;

    /** Ordinate (second coordinate). */
    private final double y;

    /** Simple constructor.
     * @param x abscissa (first coordinate)
     * @param y ordinate (second coordinate)
     */
<span class="fc" id="L81">    private Vector2D(final double x, final double y) {</span>
<span class="fc" id="L82">        this.x = x;</span>
<span class="fc" id="L83">        this.y = y;</span>
<span class="fc" id="L84">    }</span>

    /** Returns the abscissa (first coordinate value) of the instance.
     * @return the abscissa
     */
    public double getX() {
<span class="fc" id="L90">        return x;</span>
    }

    /** Returns the ordinate (second coordinate value) of the instance.
     * @return the ordinate
     */
    public double getY() {
<span class="fc" id="L97">        return y;</span>
    }

    /** Get the coordinates for this instance as a dimension 2 array.
     * @return coordinates for this instance
     */
    public double[] toArray() {
<span class="fc" id="L104">        return new double[]{x, y};</span>
    }

    /** {@inheritDoc} */
    @Override
    public int getDimension() {
<span class="fc" id="L110">        return 2;</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isNaN() {
<span class="fc bfc" id="L116" title="All 4 branches covered.">        return Double.isNaN(x) || Double.isNaN(y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isInfinite() {
<span class="fc bfc" id="L122" title="All 6 branches covered.">        return !isNaN() &amp;&amp; (Double.isInfinite(x) || Double.isInfinite(y));</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean isFinite() {
<span class="fc bfc" id="L128" title="All 4 branches covered.">        return Double.isFinite(x) &amp;&amp; Double.isFinite(y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D vectorTo(final Vector2D v) {
<span class="fc" id="L134">        return v.subtract(this);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Unit directionTo(final Vector2D v) {
<span class="fc" id="L140">        return vectorTo(v).normalize();</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D lerp(final Vector2D p, final double t) {
<span class="fc" id="L146">        return Sum.create()</span>
<span class="fc" id="L147">                .addScaled(1.0 - t, this)</span>
<span class="fc" id="L148">                .addScaled(t, p).get();</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D getZero() {
<span class="fc" id="L154">        return ZERO;</span>
    }

    /** {@inheritDoc} */
    @Override
    public double norm() {
<span class="fc" id="L160">        return Vectors.norm(x, y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public double normSq() {
<span class="fc" id="L166">        return Vectors.normSq(x, y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D withNorm(final double magnitude) {
<span class="fc" id="L172">        final double invNorm = 1.0 / getCheckedNorm();</span>

<span class="fc" id="L174">        return new Vector2D(</span>
                    magnitude * x * invNorm,
                    magnitude * y * invNorm
                );
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D add(final Vector2D v) {
<span class="fc" id="L183">        return new Vector2D(x + v.x, y + v.y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D add(final double factor, final Vector2D v) {
<span class="fc" id="L189">        return new Vector2D(x + (factor * v.x), y + (factor * v.y));</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D subtract(final Vector2D v) {
<span class="fc" id="L195">        return new Vector2D(x - v.x, y - v.y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D subtract(final double factor, final Vector2D v) {
<span class="fc" id="L201">        return new Vector2D(x - (factor * v.x), y - (factor * v.y));</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D negate() {
<span class="fc" id="L207">        return new Vector2D(-x, -y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Unit normalize() {
<span class="fc" id="L213">        return Unit.from(x, y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Unit normalizeOrNull() {
<span class="fc" id="L219">        return Unit.tryCreateNormalized(x, y, false);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D multiply(final double a) {
<span class="fc" id="L225">        return new Vector2D(a * x, a * y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public double distance(final Vector2D v) {
<span class="fc" id="L231">        return Vectors.norm(x - v.x, y - v.y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public double distanceSq(final Vector2D v) {
<span class="fc" id="L237">        return Vectors.normSq(x - v.x, y - v.y);</span>
    }

    /** {@inheritDoc} */
    @Override
    public double dot(final Vector2D v) {
<span class="fc" id="L243">        return Vectors.linearCombination(x, v.x, y, v.y);</span>
    }

    /** {@inheritDoc}
     * &lt;p&gt;This method computes the angular separation between the two
     * vectors using the dot product for well separated vectors and the
     * cross product for almost aligned vectors. This allows to have a
     * good accuracy in all cases, even for vectors very close to each
     * other.&lt;/p&gt;
     */
    @Override
    public double angle(final Vector2D v) {
<span class="fc" id="L255">        final double normProduct = getCheckedNorm() * v.getCheckedNorm();</span>

<span class="fc" id="L257">        final double dot = dot(v);</span>
<span class="fc" id="L258">        final double threshold = normProduct * 0.9999;</span>
<span class="fc bfc" id="L259" title="All 4 branches covered.">        if ((dot &lt; -threshold) || (dot &gt; threshold)) {</span>
            // the vectors are almost aligned, compute using the sine
<span class="fc" id="L261">            final double n = Math.abs(Vectors.linearCombination(x, v.y, -y, v.x));</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">            if (dot &gt;= 0) {</span>
<span class="fc" id="L263">                return Math.asin(n / normProduct);</span>
            }
<span class="fc" id="L265">            return Math.PI - Math.asin(n / normProduct);</span>
        }

        // the vectors are sufficiently separated to use the cosine
<span class="fc" id="L269">        return Math.acos(dot / normProduct);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D project(final Vector2D base) {
<span class="fc" id="L275">        return getComponent(base, false, Vector2D::new);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D reject(final Vector2D base) {
<span class="fc" id="L281">        return getComponent(base, true, Vector2D::new);</span>
    }

    /** {@inheritDoc}
     * The returned vector is computed by rotating the current instance {@code pi/2} radians
     * counterclockwise around the origin and normalizing. For example, if this method is
     * called on a vector pointing along the positive x-axis, then a unit vector representing
     * the positive y-axis is returned.
     * @return a unit vector orthogonal to the current instance
     * @throws IllegalArgumentException if the norm of the current instance is zero, NaN, or infinite
     */
    @Override
    public Vector2D.Unit orthogonal() {
<span class="fc" id="L294">        return Unit.from(-y, x);</span>
    }

    /** {@inheritDoc} */
    @Override
    public Vector2D.Unit orthogonal(final Vector2D dir) {
<span class="fc" id="L300">        return dir.getComponent(this, true, Vector2D.Unit::from);</span>
    }

    /** Compute the signed area of the parallelogram with sides formed by this instance
     * and the given vector.
     *
     * &lt;p&gt;The parallelogram in question can be visualized by taking the current instance as the
     * first side and placing {@code v} at the end of it to create the second. The other sides
     * are formed by lines parallel to these two vectors. If {@code v} points to the &lt;em&gt;left&lt;/em&gt; of
     * the current instance (ie, the parallelogram is wound counter-clockwise), then the
     * returned area is positive. If {@code v} points to the &lt;em&gt;right&lt;/em&gt; of the current instance,
     * (ie, the parallelogram is wound clockwise), then the returned area is negative. If
     * the vectors are collinear (ie, they lie on the same line), then 0 is returned. The area of
     * the triangle formed by the two vectors is exactly half of the returned value.
     * @param v vector representing the second side of the constructed parallelogram
     * @return the signed area of the parallelogram formed by this instance and the given vector
     */
    public double signedArea(final Vector2D v) {
<span class="fc" id="L318">        return Vectors.linearCombination(</span>
                x, v.y,
                -y, v.x);
    }

    /** Convenience method to apply a function to this vector. This
     * can be used to transform the vector inline with other methods.
     * @param fn the function to apply
     * @return the transformed vector
     */
    public Vector2D transform(final UnaryOperator&lt;Vector2D&gt; fn) {
<span class="fc" id="L329">        return fn.apply(this);</span>
    }

    /** {@inheritDoc} */
    @Override
    public boolean eq(final Vector2D vec, final Precision.DoubleEquivalence precision) {
<span class="fc bfc" id="L335" title="All 2 branches covered.">        return precision.eq(x, vec.x) &amp;&amp;</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                precision.eq(y, vec.y);</span>
    }

    /**
     * Get a hashCode for the 2D coordinates.
     * &lt;p&gt;
     * All NaN values have the same hash code.&lt;/p&gt;
     *
     * @return a hash code value for this object
     */
    @Override
    public int hashCode() {
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (isNaN()) {</span>
<span class="fc" id="L349">            return 542;</span>
        }
<span class="fc" id="L351">        return 122 * (76 * Double.hashCode(x) + Double.hashCode(y));</span>
    }

    /**
     * Test for the equality of two vector instances.
     * &lt;p&gt;
     * If all coordinates of two vectors are exactly the same, and none are
     * &lt;code&gt;Double.NaN&lt;/code&gt;, the two instances are considered to be equal.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;code&gt;NaN&lt;/code&gt; coordinates are considered to globally affect the vector
     * and be equal to each other - i.e, if either (or all) coordinates of the
     * vector are equal to &lt;code&gt;Double.NaN&lt;/code&gt;, the vector is equal to
     * {@link #NaN}.
     * &lt;/p&gt;
     *
     * @param other Object to test for equality to this
     * @return true if two Vector2D objects are equal, false if
     *         object is null, not an instance of Vector2D, or
     *         not equal to this Vector2D instance
     *
     */
    @Override
    public boolean equals(final Object other) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (this == other) {</span>
<span class="fc" id="L376">            return true;</span>
        }
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (other instanceof Vector2D) {</span>
<span class="fc" id="L379">            final Vector2D rhs = (Vector2D) other;</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            if (rhs.isNaN()) {</span>
<span class="fc" id="L381">                return this.isNaN();</span>
            }

<span class="fc bfc" id="L384" title="All 2 branches covered.">            return Double.compare(x, rhs.x) == 0 &amp;&amp;</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">                    Double.compare(y, rhs.y) == 0;</span>
        }
<span class="fc" id="L387">        return false;</span>
    }

    /** {@inheritDoc} */
    @Override
    public String toString() {
<span class="fc" id="L393">        return SimpleTupleFormat.getDefault().format(x, y);</span>
    }

    /** Returns a component of the current instance relative to the given base
     * vector. If {@code reject} is true, the vector rejection is returned; otherwise,
     * the projection is returned.
     * @param base The base vector
     * @param reject If true, the rejection of this instance from {@code base} is
     *      returned. If false, the projection of this instance onto {@code base}
     *      is returned.
     * @param factory factory function used to build the final vector
     * @param &lt;T&gt; Vector implementation type
     * @return The projection or rejection of this instance relative to {@code base},
     *      depending on the value of {@code reject}.
     * @throws IllegalArgumentException if {@code base} has a zero, NaN, or infinite norm
     */
    private &lt;T extends Vector2D&gt; T getComponent(final Vector2D base, final boolean reject,
            final DoubleFunction2N&lt;T&gt; factory) {
<span class="fc" id="L411">        final double aDotB = dot(base);</span>

        // We need to check the norm value here to ensure that it's legal. However, we don't
        // want to incur the cost or floating point error of getting the actual norm and then
        // multiplying it again to get the square norm. So, we'll just check the squared norm
        // directly. This will produce the same error result as checking the actual norm since
        // Math.sqrt(0.0) == 0.0, Math.sqrt(Double.NaN) == Double.NaN and
        // Math.sqrt(Double.POSITIVE_INFINITY) == Double.POSITIVE_INFINITY.
<span class="fc" id="L419">        final double baseMagSq = Vectors.checkedNorm(base.normSq());</span>

<span class="fc" id="L421">        final double scale = aDotB / baseMagSq;</span>

<span class="fc" id="L423">        final double projX = scale * base.x;</span>
<span class="fc" id="L424">        final double projY = scale * base.y;</span>

<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (reject) {</span>
<span class="fc" id="L427">            return factory.apply(x - projX, y - projY);</span>
        }

<span class="fc" id="L430">        return factory.apply(projX, projY);</span>
    }

    /** Returns a vector with the given coordinate values.
     * @param x abscissa (first coordinate value)
     * @param y abscissa (second coordinate value)
     * @return vector instance
     */
    public static Vector2D of(final double x, final double y) {
<span class="fc" id="L439">        return new Vector2D(x, y);</span>
    }

    /** Creates a vector from the coordinates in the given 2-element array.
     * @param v coordinates array
     * @return new vector
     * @exception IllegalArgumentException if the array does not have 2 elements
     */
    public static Vector2D of(final double[] v) {
<span class="fc bfc" id="L448" title="All 2 branches covered.">        if (v.length != 2) {</span>
<span class="fc" id="L449">            throw new IllegalArgumentException(&quot;Dimension mismatch: &quot; + v.length + &quot; != 2&quot;);</span>
        }
<span class="fc" id="L451">        return new Vector2D(v[0], v[1]);</span>
    }

    /** Parses the given string and returns a new vector instance. The expected string
     * format is the same as that returned by {@link #toString()}.
     * @param str the string to parse
     * @return vector instance represented by the string
     * @throws IllegalArgumentException if the given string has an invalid format
     */
    public static Vector2D parse(final String str) {
<span class="fc" id="L461">        return SimpleTupleFormat.getDefault().parse(str, Vector2D::new);</span>
    }

    /** Return a vector containing the maximum component values from all input vectors.
     * @param first first vector
     * @param more additional vectors
     * @return a vector containing the maximum component values from all input vectors
     */
    public static Vector2D max(final Vector2D first, final Vector2D... more) {
<span class="fc" id="L470">        return computeMax(first, Arrays.asList(more).iterator());</span>
    }

    /** Return a vector containing the maximum component values from all input vectors.
     * @param vecs input vectors
     * @return a vector containing the maximum component values from all input vectors
     * @throws IllegalArgumentException if the argument does not contain any vectors
     */
    public static Vector2D max(final Iterable&lt;Vector2D&gt; vecs) {
<span class="fc" id="L479">        final Iterator&lt;Vector2D&gt; it = vecs.iterator();</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (!it.hasNext()) {</span>
<span class="fc" id="L481">            throw new IllegalArgumentException(&quot;Cannot compute vector max: no vectors given&quot;);</span>
        }

<span class="fc" id="L484">        return computeMax(it.next(), it);</span>
    }

    /** Internal method for computing a max vector.
     * @param first first vector
     * @param more iterator with additional vectors
     * @return vector containing the maximum component values of all input vectors
     */
    private static Vector2D computeMax(final Vector2D first, final Iterator&lt;? extends Vector2D&gt; more) {
<span class="fc" id="L493">        double x = first.getX();</span>
<span class="fc" id="L494">        double y = first.getY();</span>

        Vector2D vec;
<span class="fc bfc" id="L497" title="All 2 branches covered.">        while (more.hasNext()) {</span>
<span class="fc" id="L498">            vec = more.next();</span>

<span class="fc" id="L500">            x = Math.max(x, vec.getX());</span>
<span class="fc" id="L501">            y = Math.max(y, vec.getY());</span>
        }

<span class="fc" id="L504">        return Vector2D.of(x, y);</span>
    }

    /** Return a vector containing the minimum component values from all input vectors.
     * @param first first vector
     * @param more more vectors
     * @return a vector containing the minimum component values from all input vectors
     */
    public static Vector2D min(final Vector2D first, final Vector2D... more) {
<span class="fc" id="L513">        return computeMin(first, Arrays.asList(more).iterator());</span>
    }

    /** Return a vector containing the minimum component values from all input vectors.
     * @param vecs input vectors
     * @return a vector containing the minimum component values from all input vectors
     * @throws IllegalArgumentException if the argument does not contain any vectors
     */
    public static Vector2D min(final Iterable&lt;Vector2D&gt; vecs) {
<span class="fc" id="L522">        final Iterator&lt;Vector2D&gt; it = vecs.iterator();</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">        if (!it.hasNext()) {</span>
<span class="fc" id="L524">            throw new IllegalArgumentException(&quot;Cannot compute vector min: no vectors given&quot;);</span>
        }

<span class="fc" id="L527">        return computeMin(it.next(), it);</span>
    }

    /** Internal method for computing a min vector.
     * @param first first vector
     * @param more iterator with additional vectors
     * @return vector containing the minimum component values of all input vectors
     */
    private static Vector2D computeMin(final Vector2D first, final Iterator&lt;? extends Vector2D&gt; more) {
<span class="fc" id="L536">        double x = first.getX();</span>
<span class="fc" id="L537">        double y = first.getY();</span>

        Vector2D vec;
<span class="fc bfc" id="L540" title="All 2 branches covered.">        while (more.hasNext()) {</span>
<span class="fc" id="L541">            vec = more.next();</span>

<span class="fc" id="L543">            x = Math.min(x, vec.getX());</span>
<span class="fc" id="L544">            y = Math.min(y, vec.getY());</span>
        }

<span class="fc" id="L547">        return Vector2D.of(x, y);</span>
    }

    /** Compute the centroid of the given points. The centroid is the arithmetic mean position of a set
     * of points.
     * @param first first point
     * @param more additional points
     * @return the centroid of the given points
     */
    public static Vector2D centroid(final Vector2D first, final Vector2D... more) {
<span class="fc" id="L557">        return computeCentroid(first, Arrays.asList(more).iterator());</span>
    }

    /** Compute the centroid of the given points. The centroid is the arithmetic mean position of a set
     * of points.
     * @param pts the points to compute the centroid of
     * @return the centroid of the given points
     * @throws IllegalArgumentException if the argument contains no points
     */
    public static Vector2D centroid(final Iterable&lt;Vector2D&gt; pts) {
<span class="fc" id="L567">        final Iterator&lt;Vector2D&gt; it = pts.iterator();</span>
<span class="fc bfc" id="L568" title="All 2 branches covered.">        if (!it.hasNext()) {</span>
<span class="fc" id="L569">            throw new IllegalArgumentException(&quot;Cannot compute centroid: no points given&quot;);</span>
        }

<span class="fc" id="L572">        return computeCentroid(it.next(), it);</span>
    }

    /** Internal method for computing the centroid of a set of points.
     * @param first first point
     * @param more iterator with additional points
     * @return the centroid of the point set
     */
    private static Vector2D computeCentroid(final Vector2D first, final Iterator&lt;? extends Vector2D&gt; more) {
<span class="fc" id="L581">        final Sum sum = Sum.of(first);</span>
<span class="fc" id="L582">        int count = 1;</span>

<span class="fc bfc" id="L584" title="All 2 branches covered.">        while (more.hasNext()) {</span>
<span class="fc" id="L585">            sum.add(more.next());</span>
<span class="fc" id="L586">            ++count;</span>
        }

<span class="fc" id="L589">        return sum.get().multiply(1.0 / count);</span>
    }

    /**
     * Represents unit vectors.
     * This allows optimizations for certain operations.
     */
    public static final class Unit extends Vector2D {
        /** Unit vector (coordinates: 1, 0). */
<span class="fc" id="L598">        public static final Unit PLUS_X  = new Unit(1d, 0d);</span>
        /** Negation of unit vector (coordinates: -1, 0). */
<span class="fc" id="L600">        public static final Unit MINUS_X = new Unit(-1d, 0d);</span>
        /** Unit vector (coordinates: 0, 1). */
<span class="fc" id="L602">        public static final Unit PLUS_Y  = new Unit(0d, 1d);</span>
        /** Negation of unit vector (coordinates: 0, -1). */
<span class="fc" id="L604">        public static final Unit MINUS_Y = new Unit(0d, -1d);</span>

        /** Maximum coordinate value for computing normalized vectors
         * with raw, unscaled values.
         */
        private static final double UNSCALED_MAX = 0x1.0p+500;

        /** Factor used to scale up coordinate values in order to produce
         * normalized coordinates without overflow or underflow.
         */
        private static final double SCALE_UP_FACTOR = 0x1.0p+600;

        /** Factor used to scale down coordinate values in order to produce
         * normalized coordinates without overflow or underflow.
         */
        private static final double SCALE_DOWN_FACTOR = 0x1.0p-600;

        /** Simple constructor. Callers are responsible for ensuring that the given
         * values represent a normalized vector.
         * @param x abscissa (first coordinate value)
         * @param y abscissa (second coordinate value)
         */
        private Unit(final double x, final double y) {
<span class="fc" id="L627">            super(x, y);</span>
<span class="fc" id="L628">        }</span>

        /** {@inheritDoc} */
        @Override
        public double norm() {
<span class="fc" id="L633">            return 1;</span>
        }

        /** {@inheritDoc} */
        @Override
        public double normSq() {
<span class="fc" id="L639">            return 1;</span>
        }

        /** {@inheritDoc} */
        @Override
        public Unit normalize() {
<span class="fc" id="L645">            return this;</span>
        }

        /** {@inheritDoc} */
        @Override
        public Unit normalizeOrNull() {
<span class="fc" id="L651">            return this;</span>
        }

        /** {@inheritDoc} */
        @Override
        public Vector2D.Unit orthogonal() {
<span class="fc" id="L657">            return new Unit(-getY(), getX());</span>
        }

        /** {@inheritDoc} */
        @Override
        public Vector2D withNorm(final double mag) {
<span class="fc" id="L663">            return multiply(mag);</span>
        }

        /** {@inheritDoc} */
        @Override
        public Unit negate() {
<span class="fc" id="L669">            return new Unit(-getX(), -getY());</span>
        }

        /** Create a normalized vector.
         * @param x Vector coordinate.
         * @param y Vector coordinate.
         * @return a vector whose norm is 1.
         * @throws IllegalArgumentException if the norm of the given value is zero, NaN,
         *      or infinite
         */
        public static Unit from(final double x, final double y) {
<span class="fc" id="L680">            return tryCreateNormalized(x, y, true);</span>
        }

        /** Create a normalized vector.
         * @param v Vector.
         * @return a vector whose norm is 1.
         * @throws IllegalArgumentException if the norm of the given value is zero, NaN,
         *      or infinite
         */
        public static Unit from(final Vector2D v) {
<span class="fc bfc" id="L690" title="All 2 branches covered.">            return v instanceof Unit ?</span>
<span class="fc" id="L691">                (Unit) v :</span>
<span class="fc" id="L692">                from(v.getX(), v.getY());</span>
        }

        /** Attempt to create a normalized vector from the given coordinate values. If {@code throwOnFailure}
         * is true, an exception is thrown if a normalized vector cannot be created. Otherwise, null
         * is returned.
         * @param x x coordinate
         * @param y y coordinate
         * @param throwOnFailure if true, an exception will be thrown if a normalized vector cannot be created
         * @return normalized vector or null if one cannot be created and {@code throwOnFailure}
         *      is false
         * @throws IllegalArgumentException if the computed norm is zero, NaN, or infinite
         */
        private static Unit tryCreateNormalized(final double x, final double y, final boolean throwOnFailure) {

            // Compute the inverse norm directly. If the result is a non-zero real number,
            // then we can go ahead and construct the unit vector immediately. If not,
            // we'll do some extra work for edge cases.
<span class="fc" id="L710">            final double norm = Vectors.norm(x, y);</span>
<span class="fc" id="L711">            final double normInv = 1.0 / norm;</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">            if (Vectors.isRealNonZero(normInv)) {</span>
<span class="fc" id="L713">                return new Unit(</span>
                        x * normInv,
                        y * normInv);
            }

            // Direct computation did not work. Try scaled versions of the coordinates
            // to handle overflow and underflow.
            final double scaledX;
            final double scaledY;

<span class="fc" id="L723">            final double maxCoord = Math.max(Math.abs(x), Math.abs(y));</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (maxCoord &gt; UNSCALED_MAX) {</span>
<span class="fc" id="L725">                scaledX = x * SCALE_DOWN_FACTOR;</span>
<span class="fc" id="L726">                scaledY = y * SCALE_DOWN_FACTOR;</span>
            } else {
<span class="fc" id="L728">                scaledX = x * SCALE_UP_FACTOR;</span>
<span class="fc" id="L729">                scaledY = y * SCALE_UP_FACTOR;</span>
            }

<span class="fc" id="L732">            final double scaledNormInv = 1.0 / Vectors.norm(scaledX, scaledY);</span>

<span class="fc bfc" id="L734" title="All 2 branches covered.">            if (Vectors.isRealNonZero(scaledNormInv)) {</span>
<span class="fc" id="L735">                return new Unit(</span>
                        scaledX * scaledNormInv,
                        scaledY * scaledNormInv);
<span class="fc bfc" id="L738" title="All 2 branches covered.">            } else if (throwOnFailure) {</span>
<span class="fc" id="L739">                throw Vectors.illegalNorm(norm);</span>
            }
<span class="fc" id="L741">            return null;</span>
        }
    }

    /** Class used to create high-accuracy sums of vectors. Each vector component is
     * summed using an instance of {@link org.apache.commons.numbers.core.Sum}.
     *
     * &lt;p&gt;This class is mutable and not thread-safe.
     * @see org.apache.commons.numbers.core.Sum
     */
    public static final class Sum extends EuclideanVectorSum&lt;Vector2D&gt; {
        /** X component sum. */
        private final org.apache.commons.numbers.core.Sum xsum;
        /** Y component sum. */
        private final org.apache.commons.numbers.core.Sum ysum;

        /** Construct a new instance with the given initial value.
         * @param initial initial value
         */
<span class="fc" id="L760">        Sum(final Vector2D initial) {</span>
<span class="fc" id="L761">            this.xsum = org.apache.commons.numbers.core.Sum.of(initial.x);</span>
<span class="fc" id="L762">            this.ysum = org.apache.commons.numbers.core.Sum.of(initial.y);</span>
<span class="fc" id="L763">        }</span>

        /** {@inheritDoc} */
        @Override
        public Sum add(final Vector2D vec) {
<span class="fc" id="L768">            xsum.add(vec.x);</span>
<span class="fc" id="L769">            ysum.add(vec.y);</span>
<span class="fc" id="L770">            return this;</span>
        }

        /** {@inheritDoc} */
        @Override
        public Sum addScaled(final double scale, final Vector2D vec) {
<span class="fc" id="L776">            xsum.addProduct(scale, vec.x);</span>
<span class="fc" id="L777">            ysum.addProduct(scale, vec.y);</span>
<span class="fc" id="L778">            return this;</span>
        }

        /** {@inheritDoc} */
        @Override
        public Vector2D get() {
<span class="fc" id="L784">            return Vector2D.of(</span>
<span class="fc" id="L785">                    xsum.getAsDouble(),</span>
<span class="fc" id="L786">                    ysum.getAsDouble());</span>
        }

        /** Create a new instance with an initial value set to the {@link Vector2D#ZERO zero vector}.
         * @return new instance set to zero
         */
        public static Sum create() {
<span class="fc" id="L793">            return new Sum(Vector2D.ZERO);</span>
        }

        /** Construct a new instance with an initial value set to the argument.
         * @param initial initial sum value
         * @return new instance
         */
        public static Sum of(final Vector2D initial) {
<span class="fc" id="L801">            return new Sum(initial);</span>
        }

        /** Construct a new instance from multiple values.
         * @param first first vector
         * @param more additional vectors
         * @return new instance
         */
        public static Sum of(final Vector2D first, final Vector2D... more) {
<span class="fc" id="L810">            final Sum s = new Sum(first);</span>
<span class="fc bfc" id="L811" title="All 2 branches covered.">            for (final Vector2D v : more) {</span>
<span class="fc" id="L812">                s.add(v);</span>
            }
<span class="fc" id="L814">            return s;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>